!function(){"use strict";var e=1e-6,n="undefined"!=typeof Float32Array?Float32Array:Array,t=Math.PI/180;function r(){var e=new n(16);return n!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)});var o=function(e,n,t,r,o){var a,i=1/Math.tan(n/2);return e[0]=i/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e};function a(){var e=new n(3);return n!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function i(e,t,r){var o=new n(3);return o[0]=e,o[1]=t,o[2]=r,o}function s(e,n,t,r){return e[0]=n,e[1]=t,e[2]=r,e}a();var c="fn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn noise3(p: vec3<f32>) -> f32 {\n  let a = floor(p);\n  var d: vec3<f32> = p - a;\n  d = d * d * (3. - 2. * d);\n\n  let b = a.xxyy + vec4<f32>(0., 1., 0., 1.);\n  let k1 = permute4(b.xyxy);\n  let k2 = permute4(k1.xyxy + b.zzww);\n\n  let c = k2 + a.zzzz;\n  let k3 = permute4(c);\n  let k4 = permute4(c + 1.);\n\n  let o1 = fract(k3 * (1. / 41.));\n  let o2 = fract(k4 * (1. / 41.));\n\n  let o3 = o2 * d.z + o1 * (1. - d.z);\n  let o4 = o3.yw * d.x + o3.xz * (1. - d.x);\n\n  return o4.y * d.y + o4.x * (1. - d.y);\n}\n\nfn simplexNoise3(v: vec3<f32>) -> f32 {\n  let C = vec2<f32>(1. / 6., 1. / 3.);\n  let D = vec4<f32>(0., 0.5, 1., 2.);\n\n  var i: vec3<f32>  = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  let x1 = x0 - i1 + 1. * C.xxx;\n  let x2 = x0 - i2 + 2. * C.xxx;\n  let x3 = x0 - 1. + 3. * C.xxx;\n\n  i = i % vec3<f32>(289.);\n  let p = permute4(permute4(permute4(\n      i.z + vec4<f32>(0., i1.z, i2.z, 1. )) +\n      i.y + vec4<f32>(0., i1.y, i2.y, 1. )) +\n      i.x + vec4<f32>(0., i1.x, i2.x, 1. ));\n\n  var n_: f32 = 1. / 7.;\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49. * floor(p * ns.z * ns.z);\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_);\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = 1.0 - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  let s0 = floor(b0)*2.0 + 1.0;\n  let s1 = floor(b1)*2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  var p0: vec3<f32> = vec3<f32>(a0.xy, h.x);\n  var p1: vec3<f32> = vec3<f32>(a0.zw, h.y);\n  var p2: vec3<f32> = vec3<f32>(a1.xy, h.z);\n  var p3: vec3<f32> = vec3<f32>(a1.zw, h.w);\n\n  let norm = taylorInvSqrt4(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 = p0 * norm.x;\n  p1 = p1 * norm.y;\n  p2 = p2 * norm.z;\n  p3 = p3 * norm.w;\n\n  var m: vec4<f32> = 0.6 - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  m = max(m, vec4<f32>(0.));\n  m = m * m;\n  return 42. * dot(m * m, vec4<f32>(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n";const u=({count:e,width:n,height:t,generator:r})=>`\n@group(0) @binding(0) var texture : texture_storage_2d_array<rgba8unorm, write>;\n\n${c}\n\nstruct Atlas {\n  count : i32,\n  width : i32,\n  height : i32,\n  stride : i32,\n  length : i32,\n}\n\nconst atlas : Atlas = Atlas(\n  ${e},\n  ${n},\n  ${t},\n  ${n*t},\n  ${e*n*t},\n);\n\nfn hue2Rgb(p : f32, q : f32, t : f32) -> f32 {\n  var h : f32 = t;\n  if (h < 0) { h += 1; }\n  if (h > 1) { h -= 1; }\n  if (h < 1 / 6.0) { return p + (q - p) * 6 * h; }\n  if (h < 1 / 2.0) { return q; }\n  if (h < 2 / 3.0) { return p + (q - p) * (2.0 / 3.0 - h) * 6; }\n  return p;\n}\n\nfn hsl2Rgba(h : f32, s: f32, l: f32) -> vec4<f32> {\n  var rgba : vec4<f32> = vec4<f32>(0, 0, 0, 1);\n  if (s == 0) {\n    rgba.r = l;\n    rgba.g = l;\n    rgba.b = l;\n  } else {\n    var q : f32;\n    if (l < 0.5) {\n      q = l * (1 + s);\n    } else {\n      q = l + s - l * s;\n    }\n    var p : f32 = 2 * l - q;\n    rgba.r = hue2Rgb(p, q, h + 1 / 3.0);\n    rgba.g = hue2Rgb(p, q, h);\n    rgba.b = hue2Rgb(p, q, h - 1 / 3.0);\n  }\n  return rgba;\n};\n\n${r}\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var id : i32 = i32(GlobalInvocationID.x);\n  if (id >= atlas.length) {\n    return;\n  }\n  var tex : i32 = id / atlas.stride;\n  var index : i32 = id - tex * atlas.stride;\n  var y : i32 = index / atlas.width;\n  var pixel : vec2<i32> = vec2<i32>(index - y * atlas.width, y);\n  textureStore(texture, pixel, tex, getColorAt(tex, pixel));\n}\n`;class f{constructor({device:e,count:n=254,width:t=16,height:r=16}){this.device=e,this.count=n,this.width=t,this.height=r,this.texture=e.createTexture({dimension:"2d",size:[t,r,n],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING})}compute(e="\nfn getColorAt(texture : i32, pixel : vec2<i32>) -> vec4<f32> {\n  var h : f32 = f32(texture) / f32(atlas.count);\n  var s : f32 = 0.5;\n  var l : f32 = 0.5;\n  if (pixel.x == 0 || pixel.y == 0 || pixel.x == (atlas.width - 1) || pixel.y == (atlas.height - 1)) {\n    l = min(l * 1.1, 1);\n  }\n  return hsl2Rgba(h, s, l);\n}\n"){if(this.generator===e)return;this.generator=e;const{device:n,count:t,width:r,height:o,texture:a}=this,i=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:u({count:t,width:r,height:o,generator:e})}),entryPoint:"main"}}),s=n.createCommandEncoder(),c=s.beginComputePass();c.setPipeline(i),c.setBindGroup(0,n.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:a.createView()}]})),c.dispatchWorkgroups(Math.ceil(t*r*o/64)),c.end(),n.queue.submit([s.finish()])}}const l=i(0,1,0),p=r();class d{constructor({device:e,aspect:t=1,fov:o=75,near:i=.1,far:s=1e3}){var c;this.device=e,this.buffer=e.createBuffer({size:48*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=t,this.fov=o,this.near=i,this.far=s,this.position=a(),this.target=a(),this.normal=(c=new n(9),n!=Float32Array&&(c[1]=0,c[2]=0,c[3]=0,c[5]=0,c[6]=0,c[7]=0),c[0]=1,c[4]=1,c[8]=1,c),this.view=r(),this.projection=r()}updateProjection(){const{device:e,buffer:n,projection:r,aspect:a,fov:i,near:s,far:c}=this;o(r,i*t,a,s,c),e.queue.writeBuffer(n,0,r)}updateView(){const{device:n,buffer:t,view:r,normal:o,position:a,target:i}=this;var s,c,u,f,d,v,x,h,g,m,y,b,z,w,S,E,T,P,B,k,A,_,C;s=r,u=i,f=l,S=(c=a)[0],E=c[1],T=c[2],P=f[0],B=f[1],k=f[2],A=u[0],_=u[1],C=u[2],Math.abs(S-A)<e&&Math.abs(E-_)<e&&Math.abs(T-C)<e?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(s):(y=S-A,b=E-_,z=T-C,d=B*(z*=w=1/Math.hypot(y,b,z))-k*(b*=w),v=k*(y*=w)-P*z,x=P*b-B*y,(w=Math.hypot(d,v,x))?(d*=w=1/w,v*=w,x*=w):(d=0,v=0,x=0),h=b*x-z*v,g=z*d-y*x,m=y*v-b*d,(w=Math.hypot(h,g,m))?(h*=w=1/w,g*=w,m*=w):(h=0,g=0,m=0),s[0]=d,s[1]=h,s[2]=y,s[3]=0,s[4]=v,s[5]=g,s[6]=b,s[7]=0,s[8]=x,s[9]=m,s[10]=z,s[11]=0,s[12]=-(d*S+v*E+x*T),s[13]=-(h*S+g*E+m*T),s[14]=-(y*S+b*E+z*T),s[15]=1),function(e,n){var t=n[0],r=n[1],o=n[2],a=n[3],i=n[4],s=n[5],c=n[6],u=n[7],f=n[8],l=n[9],p=n[10],d=n[11],v=n[12],x=n[13],h=n[14],g=n[15],m=t*s-r*i,y=t*c-o*i,b=t*u-a*i,z=r*c-o*s,w=r*u-a*s,S=o*u-a*c,E=f*x-l*v,T=f*h-p*v,P=f*g-d*v,B=l*h-p*x,k=l*g-d*x,A=p*g-d*h,_=m*A-y*k+b*B+z*P-w*T+S*E;_&&(_=1/_,e[0]=(s*A-c*k+u*B)*_,e[1]=(c*P-i*A-u*T)*_,e[2]=(i*k-s*P+u*E)*_,e[3]=(o*k-r*A-a*B)*_,e[4]=(t*A-o*P+a*T)*_,e[5]=(r*P-t*k-a*E)*_,e[6]=(x*S-h*w+g*z)*_,e[7]=(h*b-v*S-g*y)*_,e[8]=(v*w-x*b+g*m)*_)}(o,function(e,n){var t=n[0],r=n[1],o=n[2],a=n[3],i=n[4],s=n[5],c=n[6],u=n[7],f=n[8],l=n[9],p=n[10],d=n[11],v=n[12],x=n[13],h=n[14],g=n[15],m=t*s-r*i,y=t*c-o*i,b=t*u-a*i,z=r*c-o*s,w=r*u-a*s,S=o*u-a*c,E=f*x-l*v,T=f*h-p*v,P=f*g-d*v,B=l*h-p*x,k=l*g-d*x,A=p*g-d*h,_=m*A-y*k+b*B+z*P-w*T+S*E;return _?(_=1/_,e[0]=(s*A-c*k+u*B)*_,e[1]=(o*k-r*A-a*B)*_,e[2]=(x*S-h*w+g*z)*_,e[3]=(p*w-l*S-d*z)*_,e[4]=(c*P-i*A-u*T)*_,e[5]=(t*A-o*P+a*T)*_,e[6]=(h*b-v*S-g*y)*_,e[7]=(f*S-p*b+d*y)*_,e[8]=(i*k-s*P+u*E)*_,e[9]=(r*P-t*k-a*E)*_,e[10]=(v*w-x*b+g*m)*_,e[11]=(l*b-f*w-d*m)*_,e[12]=(s*T-i*B-c*E)*_,e[13]=(t*B-r*T+o*E)*_,e[14]=(x*y-v*z-h*m)*_,e[15]=(f*z-l*y+p*m)*_,e):null}(p,r)),n.queue.writeBuffer(t,64,r),n.queue.writeBuffer(t,128,o)}}var v="const PI : f32 = 3.141592653589793;\n\nfn rotateX(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    1, 0, 0,\n    0, c, s,\n    0, -s, c,\n  );\n}\n\nfn rotateY(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c,\n  );\n}\n\nfn rotateZ(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, s, 0,\n    -s, c, 0,\n    0, 0, 1,\n  );\n}\n";class x{constructor({device:e,format:n}){this.device=e,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},this.effects=(e=>{const n=new Float32Array([0,0,0,.3,.5,.5]),t=e.createBuffer({size:32,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,mappedAtCreation:!0});return new Float32Array(t.getMappedRange()).set(n),t.unmap(),{buffer:t,edges:{get color(){return n.subarray(0,3)},set color(r){n.set(r),e.queue.writeBuffer(t,0,n,0,3)},get intensity(){return n[3]},set intensity(r){n[3]=r,e.queue.writeBuffer(t,12,n,3,1)},get depthScale(){return n[4]},set depthScale(r){n[4]=r,e.queue.writeBuffer(t,16,n,4,1)},get normalScale(){return n[5]},set normalScale(r){n[5]=r,e.queue.writeBuffer(t,20,n,5,1)}}}})(e),this.geometry=(e=>{const n=e.createBuffer({size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1]),n.unmap(),n})(e),this.pipeline=e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:"\n@vertex\nfn main(@location(0) position : vec4<f32>) -> @builtin(position) vec4<f32> {\n  return position;\n}\n"}),entryPoint:"main",buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]}]},fragment:{module:e.createShaderModule({code:"\nstruct Edges {\n  color : vec3<f32>,\n  intensity : f32,\n  depthScale : f32,\n  normalScale : f32,\n}\n\nstruct Effects {\n  edges : Edges,\n}\n\n@group(0) @binding(0) var<uniform> effects : Effects;\n@group(0) @binding(1) var colorTexture : texture_2d<f32>;\n@group(0) @binding(2) var normalTexture : texture_2d<f32>;\n@group(0) @binding(3) var positionTexture : texture_2d<f32>;\n\nconst offset : vec3<i32> = vec3<i32>(1, 1, 0);\n\nfn edgesDepth(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : f32 = textureLoad(positionTexture, pixel, 0).z;\n  var pixelLeft : f32 = textureLoad(positionTexture, pixel - offset.xz, 0).z;\n  var pixelRight : f32 = textureLoad(positionTexture, pixel + offset.xz, 0).z;\n  var pixelUp : f32 = textureLoad(positionTexture, pixel + offset.zy, 0).z;\n  var pixelDown : f32 = textureLoad(positionTexture, pixel - offset.zy, 0).z;\n  return (\n    abs(pixelLeft    - pixelCenter) \n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter) \n  ) * effects.edges.depthScale;\n}\n\nfn edgesNormal(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : vec3<f32> = textureLoad(normalTexture, pixel, 0).xyz;\n  var pixelLeft : vec3<f32> = textureLoad(normalTexture, pixel - offset.xz, 0).xyz;\n  var pixelRight : vec3<f32> = textureLoad(normalTexture, pixel + offset.xz, 0).xyz;\n  var pixelUp : vec3<f32> = textureLoad(normalTexture, pixel + offset.zy, 0).xyz;\n  var pixelDown : vec3<f32> = textureLoad(normalTexture, pixel - offset.zy, 0).xyz;\n  var edge : vec3<f32> = (\n    abs(pixelLeft    - pixelCenter)\n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter)\n  );\n  return (edge.x + edge.y + edge.z) * effects.edges.normalScale;\n}\n\n@fragment\nfn main(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  var pixel : vec2<i32> = vec2<i32>(floor(uv.xy));\n  var color : vec3<f32> = textureLoad(colorTexture, pixel, 0).xyz;\n  if (effects.edges.intensity != 0) {\n    color = mix(color, effects.edges.color, clamp(max(edgesDepth(pixel), edgesNormal(pixel)), 0, 1) * effects.edges.intensity);\n  }\n  return vec4<f32>(color, 1);\n}\n"}),entryPoint:"main",targets:[{format:n}]},primitive:{topology:"triangle-list"}})}bindTextures({color:e,normal:n,position:t}){const{device:r,effects:o,pipeline:a}=this;this.bindings=r.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:o.buffer}},{binding:1,resource:e},{binding:2,resource:n},{binding:3,resource:t}]})}render(e,n){const{bindings:t,descriptor:r,geometry:o,pipeline:a}=this;r.colorAttachments[0].view=n;const i=e.beginRenderPass(r);i.setPipeline(a),i.setBindGroup(0,t),i.setVertexBuffer(0,o),i.draw(6,1,0,0),i.end()}}const h=`\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) face : vec4<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) viewPosition: vec3<f32>,\n  @location(1) normal: vec3<f32>,\n  @location(2) uv: vec2<f32>,\n  @location(3) @interpolate(flat) texture: i32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n  normal : mat3x3<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n${v}\n\nconst faceNormal : vec3<f32> = vec3<f32>(0, 0, 1);\n\n@vertex\nfn main(voxel : VertexInput) -> VertexOutput {\n  var rotation : mat3x3<f32>;\n  switch (u32(voxel.face.w % 6)) {\n    default {\n      rotation = mat3x3<f32>(\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1,\n      );\n    }\n    case 1 {\n      rotation = rotateX(PI * -0.5);\n    }\n    case 2 {\n      rotation = rotateX(PI * 0.5);\n    }\n    case 3 {\n      rotation = rotateY(PI * -0.5);\n    }\n    case 4 {\n      rotation = rotateY(PI * 0.5);\n    }\n    case 5 {\n      rotation = rotateY(PI);\n    }\n  }\n  var mvPosition : vec4<f32> = camera.view * vec4<f32>(rotation * voxel.position + voxel.face.xyz, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.viewPosition = -mvPosition.xyz;\n  out.normal = normalize(camera.normal * rotation * faceNormal);\n  out.uv = voxel.uv;\n  out.texture = i32(floor(voxel.face.w / 6));\n  return out;\n}\n`,g=e=>{const n=e.createBuffer({size:30*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-.5,-.5,.5,0,1,.5,-.5,.5,1,1,.5,.5,.5,1,0,.5,.5,.5,1,0,-.5,.5,.5,0,0,-.5,-.5,.5,0,1]),n.unmap(),n};class m{constructor({adapter:e,device:n,atlas:t=null,camera:r=null,canvas:o=null,samples:a=4}){const i=navigator.gpu.getPreferredCanvasFormat(e);this.atlas=t||new f({device:n}),this.camera=r||new d({device:n}),this.canvas=o||document.createElement("canvas"),this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight,this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:n,format:i}),this.device=n,this.samples=a;const s=n.createRenderPipeline({layout:"auto",vertex:{module:n.createShaderModule({code:h}),entryPoint:"main",buffers:[{arrayStride:5*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]},{arrayStride:4*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x4"}]}]},fragment:{module:n.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>,\n  @location(3) @interpolate(flat) texture : i32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) normal : vec4<f32>,\n  @location(2) position : vec4<f32>,\n}\n\n@group(0) @binding(1) var atlas : texture_2d_array<f32>;\n@group(0) @binding(2) var atlasSampler : sampler;\n\n@fragment\nfn main(face : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = textureSample(atlas, atlasSampler, face.uv, face.texture);\n  output.normal = vec4<f32>(normalize(face.normal), 1);\n  output.position = vec4<f32>(face.position, 1);\n  return output;\n}\n"}),entryPoint:"main",targets:[{format:"rgba8unorm"},{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:this.samples}});this.rendering={bindings:n.createBindGroup({layout:s.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.camera.buffer}},{binding:1,resource:this.atlas.texture.createView()},{binding:2,resource:n.createSampler()}]}),descriptor:{colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},geometry:g(n),pipeline:s},this.postprocessing=new x({device:n,format:i})}render(e,n){const{context:t,postprocessing:r,rendering:{bindings:o,descriptor:a,geometry:i,pipeline:s}}=this,c=e.beginRenderPass(a);c.setPipeline(s),c.setBindGroup(0,o),c.setVertexBuffer(0,i),n.chunks.forEach((({faces:e})=>{c.setVertexBuffer(1,e,16),c.drawIndirect(e,0)})),c.end(),r.render(e,t.getCurrentTexture().createView())}setClearColor(e,n,t){const{rendering:{descriptor:{colorAttachments:[{clearValue:r}]}}}=this;r.r=e,r.g=n,r.b=t}setSize(e,n){const{camera:t,canvas:r,device:o,postprocessing:a,rendering:i,samples:s}=this,c=window.devicePixelRatio||1,u=[Math.floor(e*c),Math.floor(n*c)];r.width=u[0],r.height=u[1],r.style.width=`${e}px`,r.style.height=`${n}px`,t.aspect=e/n,t.updateProjection();const f=(e,n,t,r)=>(e[n]&&e[n].destroy(),e[n]=o.createTexture({size:u,sampleCount:t,format:r,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),e[n].createView());i.descriptor.colorAttachments[0].view=f(i,"colorTexture",s,"rgba8unorm"),i.descriptor.colorAttachments[0].resolveTarget=f(i,"colorTarget",1,"rgba8unorm"),i.descriptor.colorAttachments[1].view=f(i,"normalTexture",s,"rgba16float"),i.descriptor.colorAttachments[1].resolveTarget=f(i,"normalTarget",1,"rgba16float"),i.descriptor.colorAttachments[2].view=f(i,"positionTexture",s,"rgba16float"),i.descriptor.colorAttachments[2].resolveTarget=f(i,"positionTarget",1,"rgba16float"),i.descriptor.depthStencilAttachment.view=f(i,"depthTexture",s,"depth24plus"),a.bindTextures({color:i.colorTarget.createView(),normal:i.normalTarget.createView(),position:i.positionTarget.createView()})}}const y=i(0,0,0),b=(e,n,t,r)=>{const o=.25*n,a=.7*r.width;var i,c,u;i=t.camera.position,c=t.camera.target,u=s(y,Math.sin(o)*a,0,Math.cos(o)*a),i[0]=c[0]+u[0],i[1]=c[1]+u[1],i[2]=c[2]+u[2],t.camera.updateView()};var z=[{onAnimation:b,onLoad:e=>e.setClearColor(.7,.6,.2),source:"\n  fn distanceToScene(pos : vec3<f32>) -> f32 {\n    var origin : vec3<f32> = pos - volume.center;\n    var size : f32 = volume.size.x * 0.3;\n    var t : f32 = sin(time);\n    return opSmoothUnion(\n      sdSphere(origin - vec3<f32>(size * (0.6 * t * -1), 0, 0), size),\n      sdSphere(origin - vec3<f32>(size * (0.6 * t), 0, 0), size),\n      6\n    );\n  }\n  fn getValueAt(pos : vec3<f32>) -> u32 {\n    if (distanceToScene(pos) > 0.01) {\n      return 0;\n    }\n    return 1 + u32(abs(simplexNoise3(pos * 0.01)) * 254.0);\n  }\n  "},{onAnimation:b,onLoad:e=>e.setClearColor(.1,.3,.6),source:"\n  fn distanceToScene(pos : vec3<f32>) -> f32 {\n    var origin : vec3<f32> = pos - volume.center;\n    var r : mat3x3<f32> = rotateX(PI * -0.5);\n    return opUnion(\n      sdTorus(\n        r * origin,\n        vec2<f32>(volume.size.x * 0.3, volume.size.x * 0.1)\n      ),\n      sdTorus(\n        r * rotateY(time) * origin,\n        vec2<f32>(volume.size.x * 0.1, volume.size.x * (0.02 + sin(time * 10) * 0.01))\n      )\n    );\n  }\n  fn getValueAt(pos : vec3<f32>) -> u32 {\n    if (distanceToScene(pos) > 0.01) {\n      return 0;\n    }\n    return 1 + u32(abs(simplexNoise3(pos * 0.01)) * 254.0);\n  }\n  "},{onAnimation:b,onLoad:e=>e.setClearColor(.1,.2,.4),source:"\n  fn getValueAt(pos : vec3<f32>) -> u32 {\n    var p : vec3<f32> = pos + vec3<f32>(0, 0, time * 100);\n    var h : f32 = abs(simplexNoise3(p * 0.01)) * volume.size.y;\n    if (pos.y > h) {\n      return 0;\n    }\n    return 1 + u32(abs(simplexNoise3(p * -0.001)) * 254.0);\n  }\n  "},{onAnimation:b,onLoad:e=>e.setClearColor(.1,.1,.1),source:"\n  fn distanceToScene(pos : vec3<f32>) -> f32 {\n    if (sdSphere(pos - volume.center, volume.size.x * 0.35) > 0.01) {\n      return 1;\n    }\n    var id : f32 = noise3(floor(pos / 32));\n    var p : vec3<f32> = (pos % 32) - 16;\n    var t : f32 = sin((time + id) * 4);\n    var d : f32;\n    if (floor(id * 10) % 2 == 0) {\n      d = sdSphere(p, t * 4 + 8);\n    } else {\n      d = sdBox(p, vec3<f32>(t * 4 + 8));\n    }\n    return opSmoothSubstraction(\n      opSmoothSubstraction(\n        d,\n        sdBox(p, vec3<f32>(4, 4, 12)),\n        1\n      ),\n      sdBox(p, vec3<f32>(12, 4, 4)),\n      1\n    );\n  }\n  fn getValueAt(pos : vec3<f32>) -> u32 {\n    if (distanceToScene(pos) > 0.01) {\n      return 0;\n    }\n    return 1 + u32(abs(simplexNoise3(floor(pos / 32))) * 254.0);\n  }\n  "}];const w=({chunkSize:e})=>`\nconst chunkSize : i32 = ${e};\n\nfn getVoxel(pos : vec3<i32>) -> u32 {\n  return u32(pos.z * chunkSize * chunkSize + pos.y * chunkSize + pos.x);\n}\n`,S=({chunkSize:e,width:n,height:t,depth:r,scene:o})=>`\n@group(0) @binding(0) var<uniform> time : f32;\n@group(0) @binding(1) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(2) var<storage, read_write> voxels : array<u32>;\n\n${c}\n${v}\nfn sdBox(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var q : vec3<f32> = abs(p) - r;\n  return length(max(q, vec3<f32>(0))) + min(max(q.x, max(q.y, q.z)), 0);\n}\n\nfn sdCapsule(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var q : vec3<f32> = vec3<f32>(p.x, clamp(p.y, -r.y + r.x, r.y - r.x), p.y);\n  return length(q) - q.x;\n}\n\nfn sdEllipsoid(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var k0 : f32 = length(p / r);\n  var k1 : f32 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\n\nfn sdSphere(p : vec3<f32>, r : f32) -> f32 {\n  return length(p) - r;\n}\n\nfn sdTorus(p : vec3<f32>, r : vec2<f32>) -> f32 {\n  var q : vec2<f32> = vec2<f32>(length(p.xz) - r.x, p.y);\n  return length(q) - r.y;\n}\n\nfn opUnion(d1 : f32, d2 : f32) -> f32 {\n  return min(d1, d2);\n}\n\nfn opSubstraction(d1 : f32, d2 : f32) -> f32 {\n  return max(d1, -d2);\n}\n\nfn opSmoothUnion(d1 : f32, d2 : f32, k : f32) -> f32 {\n  var h : f32 = clamp(0.5 + 0.5 * (d2 - d1) / k, 0, 1);\n  return mix(d2, d1, h) + k * h * (1 - h);\n}\n\nfn opSmoothSubstraction(d1 : f32, d2 : f32, k : f32) -> f32 {\n  var h : f32 = clamp(0.5 - 0.5 * (d2 + d1) / k, 0, 1);\n  return mix(d1, -d2, h) + k * h * (1 - h);\n}\n\n${w({chunkSize:e})}\n\nstruct Volume {\n  center : vec3<f32>,\n  size : vec3<f32>,\n}\n\nconst volume : Volume = Volume(\n  vec3<f32>(${.5*n}, ${.5*t}, ${.5*r}),\n  vec3<f32>(${n}, ${t}, ${r})\n);\n\n${o}\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize || pos.y >= chunkSize || pos.z >= chunkSize\n  ) {\n    return;\n  }\n  voxels[getVoxel(pos)] = getValueAt(vec3<f32>(chunk + pos));\n}\n`,E=({chunkSize:e})=>`\nstruct Faces {\n  vertexCount : u32,\n  instanceCount : atomic<u32>,\n  firstVertex : u32,\n  firstInstance : u32,\n  data : array<f32>,\n}\n\n@group(0) @binding(0) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(1) var<storage, read_write> faces : Faces;\n@group(0) @binding(2) var<storage, read> voxels : array<u32>;\n@group(0) @binding(3) var<storage, read> voxels_north : array<u32>;\n@group(0) @binding(4) var<storage, read> voxels_top : array<u32>;\n@group(0) @binding(5) var<storage, read> voxels_bottom : array<u32>;\n@group(0) @binding(6) var<storage, read> voxels_west : array<u32>;\n@group(0) @binding(7) var<storage, read> voxels_east : array<u32>;\n@group(0) @binding(8) var<storage, read> voxels_south : array<u32>;\n\n${w({chunkSize:e})}\n\nfn getValue(pos : vec3<i32>) -> u32 {\n  if (pos.x == -1) {\n    return voxels_west[getVoxel(vec3<i32>(chunkSize - 1, pos.y, pos.z))];\n  }\n  if (pos.x == chunkSize) {\n    return voxels_east[getVoxel(vec3<i32>(0, pos.y, pos.z))];\n  }\n  if (pos.y == -1) {\n    return voxels_bottom[getVoxel(vec3<i32>(pos.x, chunkSize - 1, pos.z))];\n  }\n  if (pos.y == chunkSize) {\n    return voxels_top[getVoxel(vec3<i32>(pos.x, 0, pos.z))];\n  }\n  if (pos.z == -1) {\n    return voxels_south[getVoxel(vec3<i32>(pos.x, pos.y, chunkSize - 1))];\n  }\n  if (pos.z == chunkSize) {\n    return voxels_north[getVoxel(vec3<i32>(pos.x, pos.y, 0))];\n  }\n  return voxels[getVoxel(pos)]; \n}\n\nfn pushFace(pos : vec3<i32>, face : u32, texture : u32) {\n  var offset : u32 = atomicAdd(&(faces.instanceCount), 1) * 4;\n  faces.data[offset] = f32(pos.x) + 0.5;\n  faces.data[offset + 1] = f32(pos.y) + 0.5;\n  faces.data[offset + 2] = f32(pos.z) + 0.5;\n  faces.data[offset + 3] = f32(texture * 6 + face);\n}\n\nconst faceNormals = array<vec3<i32>, 6>(\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 1, 0),\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(0, 0, -1),\n);\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize || pos.y >= chunkSize || pos.z >= chunkSize\n  ) {\n    return;\n  }\n  var value : u32 = voxels[getVoxel(pos)]; \n  if (value != 0) {\n    for (var face : u32 = 0; face < 6; face++) {\n      var npos : vec3<i32> = pos + faceNormals[face];\n      if (getValue(npos) == 0) {\n        pushFace(chunk + pos, face, value - 1);\n      }\n    }\n  }\n}\n`,T=(e,n,t)=>{const r=e.createBuffer({mappedAtCreation:!0,size:(4+6*Math.ceil(n*n*n*.5)*4)*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX});new Uint32Array(r.getMappedRange())[0]=6,r.unmap();const o=e.createBuffer({mappedAtCreation:!0,size:3*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM});return new Int32Array(o.getMappedRange()).set([t.x*n,t.y*n,t.z*n]),o.unmap(),{chunk:t,position:o,faces:r,voxels:e.createBuffer({size:n*n*n*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),resetInstanceCount(e){e.clearBuffer(r,4,4)}}},P=e=>{const n=new Float32Array(1);return{buffer:e.createBuffer({size:n.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),set(t){n[0]=t,e.queue.writeBuffer(this.buffer,0,n)}}};class B{constructor({device:e,width:n,height:t,depth:r,chunkSize:o=100}){this.chunkSize=o,this.device=e,this.width=n,this.height=t,this.depth=r,this.time=P(e);const a=Math.ceil(n/o),i=Math.ceil(t/o),s=Math.ceil(r/o);this.chunks=[];for(let n=0;n<s;n++)for(let t=0;t<i;t++)for(let r=0;r<a;r++)this.chunks.push(T(e,o,{x:r,y:t,z:n}));this.edge=e.createBuffer({size:o*o*o*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE});const c=(e,n)=>{const t=e.x+n.x,r=e.y+n.y,o=e.z+n.z;if(t<0||t>=a||r<0||r>=i||o<0||o>=s)return this.edge;const c=o*a*i+r*a+t;return this.chunks[c].voxels},u=e.createComputePipeline({layout:"auto",compute:{module:e.createShaderModule({code:E({chunkSize:o})}),entryPoint:"main"}});this.mesher={bindings:this.chunks.map((n=>e.createBindGroup({layout:u.getBindGroupLayout(0),entries:[n.position,n.faces,n.voxels,c(n.chunk,{x:0,y:0,z:1}),c(n.chunk,{x:0,y:1,z:0}),c(n.chunk,{x:0,y:-1,z:0}),c(n.chunk,{x:-1,y:0,z:0}),c(n.chunk,{x:1,y:0,z:0}),c(n.chunk,{x:0,y:0,z:-1})].map(((e,n)=>({binding:n,resource:{buffer:e}})))}))),pipeline:u}}compute(e,n){const{chunks:t,chunkSize:r,time:o,mesher:a,voxelizer:i}=this;o.set(n),t.forEach(((n,t)=>{const o=e.beginComputePass();o.setPipeline(i.pipeline),o.setBindGroup(0,i.bindings[t]),o.dispatchWorkgroups(Math.ceil(r/4),Math.ceil(r/4),Math.ceil(r/4)),o.end()})),t.forEach(((n,t)=>{n.resetInstanceCount(e);const o=e.beginComputePass();o.setPipeline(a.pipeline),o.setBindGroup(0,a.bindings[t]),o.dispatchWorkgroups(Math.ceil(r/4),Math.ceil(r/4),Math.ceil(r/4)),o.end()}))}destroy(){const{chunks:e,edge:n,time:t}=this;e.forEach((({faces:e,position:n,voxels:t})=>{e.destroy(),n.destroy(),t.destroy()})),n.destroy(),t.buffer.destroy()}setScene(e){const{device:n,chunks:t,chunkSize:r,width:o,height:a,depth:i,time:s}=this,c=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:S({chunkSize:r,width:o,height:a,depth:i,scene:e})}),entryPoint:"main"}});this.voxelizer={bindings:t.map((({position:e,voxels:t})=>n.createBindGroup({layout:c.getBindGroupLayout(0),entries:[s.buffer,e,t].map(((e,n)=>({binding:n,resource:{buffer:e}})))}))),pipeline:c}}}(async()=>{if(!navigator.gpu||!navigator.gpu.getPreferredCanvasFormat)throw new Error("WebGPU");const e=await navigator.gpu.requestAdapter(),n=await e.requestDevice(),t=new m({adapter:e,device:n});document.getElementById("renderer").appendChild(t.canvas),t.setSize(window.innerWidth,window.innerHeight),window.addEventListener("resize",(()=>t.setSize(window.innerWidth,window.innerHeight)),!1);const r=new B({device:n,width:300,height:300,depth:300});s(t.camera.target,.5*r.width,.5*r.height,.5*r.depth);let o,a,i,c=performance.now()/1e3;const u=document.getElementById("source"),f=e=>{o=z[e],a=e,i=-1;let n=o.source;n.includes("fn distanceToScene(pos : vec3<f32>) -> f32")&&(n=n.slice(0,n.indexOf("fn getValueAt(pos : vec3<f32>) -> u32"))),u.innerText=n,t.atlas.compute(o.atlas),r.setScene(o.source),o.onLoad&&o.onLoad(t,r)};f(0),setInterval((()=>f((a+1)%z.length)),1e4);const l=()=>{requestAnimationFrame(l);const e=performance.now()/1e3,a=e-c;c=e,o.onAnimation&&o.onAnimation(a,e,t,r);const s=n.createCommandEncoder();(void 0===o.maxFPS||o.maxFPS>0&&i<=e-1/o.maxFPS||-1===i)&&(i=e,r.compute(s,e)),t.render(s,r),n.queue.submit([s.finish()])};requestAnimationFrame(l)})().catch((e=>{console.error(e),document.getElementById("canary").classList.add("enabled")})).finally((()=>document.getElementById("loading").classList.remove("enabled")))}();
