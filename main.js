!function(){"use strict";var e=1e-6,t="undefined"!=typeof Float32Array?Float32Array:Array,r=Math.PI/180;function n(){var e=new t(16);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function s(e,t,r){var n=t[0],s=t[1],i=t[2],o=t[3],a=t[4],c=t[5],u=t[6],l=t[7],f=t[8],h=t[9],p=t[10],g=t[11],d=t[12],m=t[13],x=t[14],v=t[15],y=r[0],T=r[1],E=r[2],b=r[3];return e[0]=y*n+T*a+E*f+b*d,e[1]=y*s+T*c+E*h+b*m,e[2]=y*i+T*u+E*p+b*x,e[3]=y*o+T*l+E*g+b*v,y=r[4],T=r[5],E=r[6],b=r[7],e[4]=y*n+T*a+E*f+b*d,e[5]=y*s+T*c+E*h+b*m,e[6]=y*i+T*u+E*p+b*x,e[7]=y*o+T*l+E*g+b*v,y=r[8],T=r[9],E=r[10],b=r[11],e[8]=y*n+T*a+E*f+b*d,e[9]=y*s+T*c+E*h+b*m,e[10]=y*i+T*u+E*p+b*x,e[11]=y*o+T*l+E*g+b*v,y=r[12],T=r[13],E=r[14],b=r[15],e[12]=y*n+T*a+E*f+b*d,e[13]=y*s+T*c+E*h+b*m,e[14]=y*i+T*u+E*p+b*x,e[15]=y*o+T*l+E*g+b*v,e}function i(e,r){var n=new t(3);!function(e,t){var r=t[0],n=t[1],s=t[2],i=t[4],o=t[5],a=t[6],c=t[8],u=t[9],l=t[10];e[0]=Math.hypot(r,n,s),e[1]=Math.hypot(i,o,a),e[2]=Math.hypot(c,u,l)}(n,r);var s=1/n[0],i=1/n[1],o=1/n[2],a=r[0]*s,c=r[1]*i,u=r[2]*o,l=r[4]*s,f=r[5]*i,h=r[6]*o,p=r[8]*s,g=r[9]*i,d=r[10]*o,m=a+f+d,x=0;return m>0?(x=2*Math.sqrt(m+1),e[3]=.25*x,e[0]=(h-g)/x,e[1]=(p-u)/x,e[2]=(c-l)/x):a>f&&a>d?(x=2*Math.sqrt(1+a-f-d),e[3]=(h-g)/x,e[0]=.25*x,e[1]=(c+l)/x,e[2]=(p+u)/x):f>d?(x=2*Math.sqrt(1+f-a-d),e[3]=(p-u)/x,e[0]=(c+l)/x,e[1]=.25*x,e[2]=(h+g)/x):(x=2*Math.sqrt(1+d-a-f),e[3]=(c-l)/x,e[0]=(p+u)/x,e[1]=(h+g)/x,e[2]=.25*x),e}function o(e,t,r,n){var s=t[0],i=t[1],o=t[2],a=t[3],c=s+s,u=i+i,l=o+o,f=s*c,h=s*u,p=s*l,g=i*u,d=i*l,m=o*l,x=a*c,v=a*u,y=a*l,T=n[0],E=n[1],b=n[2];return e[0]=(1-(g+m))*T,e[1]=(h+y)*T,e[2]=(p-v)*T,e[3]=0,e[4]=(h-y)*E,e[5]=(1-(f+m))*E,e[6]=(d+x)*E,e[7]=0,e[8]=(p+v)*b,e[9]=(d-x)*b,e[10]=(1-(f+g))*b,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var a=function(e,t,r,n,s){var i,o=1/Math.tan(t/2);return e[0]=o/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=s&&s!==1/0?(i=1/(n-s),e[10]=(s+n)*i,e[14]=2*s*n*i):(e[10]=-1,e[14]=-2*n),e};function c(){var e=new t(3);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function u(e){var t=e[0],r=e[1],n=e[2];return Math.hypot(t,r,n)}function l(e,r,n){var s=new t(3);return s[0]=e,s[1]=r,s[2]=n,s}function f(e,t,r,n){return e[0]=t,e[1]=r,e[2]=n,e}var h=function(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e};c();var p="fn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn noise3(p: vec3<f32>) -> f32 {\n  let a = floor(p);\n  var d: vec3<f32> = p - a;\n  d = d * d * (3. - 2. * d);\n\n  let b = a.xxyy + vec4<f32>(0., 1., 0., 1.);\n  let k1 = permute4(b.xyxy);\n  let k2 = permute4(k1.xyxy + b.zzww);\n\n  let c = k2 + a.zzzz;\n  let k3 = permute4(c);\n  let k4 = permute4(c + 1.);\n\n  let o1 = fract(k3 * (1. / 41.));\n  let o2 = fract(k4 * (1. / 41.));\n\n  let o3 = o2 * d.z + o1 * (1. - d.z);\n  let o4 = o3.yw * d.x + o3.xz * (1. - d.x);\n\n  return o4.y * d.y + o4.x * (1. - d.y);\n}\n\nfn simplexNoise3(v: vec3<f32>) -> f32 {\n  let C = vec2<f32>(1. / 6., 1. / 3.);\n  let D = vec4<f32>(0., 0.5, 1., 2.);\n\n  var i: vec3<f32>  = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  let x1 = x0 - i1 + 1. * C.xxx;\n  let x2 = x0 - i2 + 2. * C.xxx;\n  let x3 = x0 - 1. + 3. * C.xxx;\n\n  i = i % vec3<f32>(289.);\n  let p = permute4(permute4(permute4(\n      i.z + vec4<f32>(0., i1.z, i2.z, 1. )) +\n      i.y + vec4<f32>(0., i1.y, i2.y, 1. )) +\n      i.x + vec4<f32>(0., i1.x, i2.x, 1. ));\n\n  var n_: f32 = 1. / 7.;\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49. * floor(p * ns.z * ns.z);\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_);\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = 1.0 - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  let s0 = floor(b0)*2.0 + 1.0;\n  let s1 = floor(b1)*2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  var p0: vec3<f32> = vec3<f32>(a0.xy, h.x);\n  var p1: vec3<f32> = vec3<f32>(a0.zw, h.y);\n  var p2: vec3<f32> = vec3<f32>(a1.xy, h.z);\n  var p3: vec3<f32> = vec3<f32>(a1.zw, h.w);\n\n  let norm = taylorInvSqrt4(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 = p0 * norm.x;\n  p1 = p1 * norm.y;\n  p2 = p2 * norm.z;\n  p3 = p3 * norm.w;\n\n  var m: vec4<f32> = 0.6 - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  m = max(m, vec4<f32>(0.));\n  m = m * m;\n  return 42. * dot(m * m, vec4<f32>(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n";const g=({count:e,width:t,height:r,generator:n})=>`\n@group(0) @binding(0) var texture : texture_storage_2d_array<rgba8unorm, write>;\n\n${p}\n\nstruct Atlas {\n  count : i32,\n  width : i32,\n  height : i32,\n  stride : i32,\n  length : i32,\n}\n\nconst atlas : Atlas = Atlas(\n  ${e},\n  ${t},\n  ${r},\n  ${t*r},\n  ${e*t*r},\n);\n\nfn hue2Rgb(p : f32, q : f32, t : f32) -> f32 {\n  var h : f32 = t;\n  if (h < 0) { h += 1; }\n  if (h > 1) { h -= 1; }\n  if (h < 1 / 6.0) { return p + (q - p) * 6 * h; }\n  if (h < 1 / 2.0) { return q; }\n  if (h < 2 / 3.0) { return p + (q - p) * (2.0 / 3.0 - h) * 6; }\n  return p;\n}\n\nfn hsl2Rgba(h : f32, s: f32, l: f32) -> vec4<f32> {\n  var rgba : vec4<f32> = vec4<f32>(0, 0, 0, 1);\n  if (s == 0) {\n    rgba.r = l;\n    rgba.g = l;\n    rgba.b = l;\n  } else {\n    var q : f32;\n    if (l < 0.5) {\n      q = l * (1 + s);\n    } else {\n      q = l + s - l * s;\n    }\n    var p : f32 = 2 * l - q;\n    rgba.r = hue2Rgb(p, q, h + 1 / 3.0);\n    rgba.g = hue2Rgb(p, q, h);\n    rgba.b = hue2Rgb(p, q, h - 1 / 3.0);\n  }\n  return rgba;\n};\n\n${n}\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var id : i32 = i32(GlobalInvocationID.x);\n  if (id >= atlas.length) {\n    return;\n  }\n  var tex : i32 = id / atlas.stride;\n  var index : i32 = id - tex * atlas.stride;\n  var y : i32 = index / atlas.width;\n  var pixel : vec2<i32> = vec2<i32>(index - y * atlas.width, y);\n  textureStore(texture, pixel, tex, getColorAt(tex, pixel));\n}\n`;class d{constructor({device:e,count:t=254,width:r=16,height:n=16}){this.device=e,this.count=t,this.width=r,this.height=n,this.texture=e.createTexture({dimension:"2d",size:[r,n,t],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING})}compute(e="\nfn getColorAt(texture : i32, pixel : vec2<i32>) -> vec4<f32> {\n  var h : f32 = f32(texture) / f32(atlas.count);\n  var s : f32 = 0.5;\n  var l : f32 = 0.5;\n  if (pixel.x == 0 || pixel.y == 0 || pixel.x == (atlas.width - 1) || pixel.y == (atlas.height - 1)) {\n    l = min(l * 1.1, 1);\n  }\n  return hsl2Rgba(h, s, l);\n}\n"){if(this.generator===e)return;this.generator=e;const{device:t,count:r,width:n,height:s,texture:i}=this,o=t.createComputePipeline({layout:"auto",compute:{module:t.createShaderModule({code:g({count:r,width:n,height:s,generator:e})}),entryPoint:"main"}}),a=t.createCommandEncoder(),c=a.beginComputePass();c.setPipeline(o),c.setBindGroup(0,t.createBindGroup({layout:o.getBindGroupLayout(0),entries:[{binding:0,resource:i.createView()}]})),c.dispatchWorkgroups(Math.ceil(r*n*s/64)),c.end(),t.queue.submit([a.finish()])}}const m=l(0,1,0),x=n();class v{constructor({device:e,aspect:t=1,fov:r=75,near:s=.1,far:i=1e3}){this.device=e,this.buffer=e.createBuffer({size:41*Float32Array.BYTES_PER_ELEMENT+12,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=t,this.fov=r,this.near=s,this.far=i,this.position=c(),this.target=c(),this.projectionMatrix=n(),this.viewBuffer=new Float32Array(25),this.viewMatrix=this.viewBuffer.subarray(0,16),this.normalMatrix=this.viewBuffer.subarray(16,25)}updateProjection(){const{device:e,buffer:t,projectionMatrix:n,aspect:s,fov:i,near:o,far:c}=this;a(n,function(e){return e*r}(i),s,o,c),e.queue.writeBuffer(t,0,n)}updateView(){const{device:t,buffer:r,viewBuffer:n,viewMatrix:s,normalMatrix:i,position:o,target:a}=this;var c,u,l,f,h,p,g,d,v,y,T,E,b,R,w,A,S,M,I,C,N,z,B;c=s,l=a,f=m,w=(u=o)[0],A=u[1],S=u[2],M=f[0],I=f[1],C=f[2],N=l[0],z=l[1],B=l[2],Math.abs(w-N)<e&&Math.abs(A-z)<e&&Math.abs(S-B)<e?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(c):(T=w-N,E=A-z,b=S-B,h=I*(b*=R=1/Math.hypot(T,E,b))-C*(E*=R),p=C*(T*=R)-M*b,g=M*E-I*T,(R=Math.hypot(h,p,g))?(h*=R=1/R,p*=R,g*=R):(h=0,p=0,g=0),d=E*g-b*p,v=b*h-T*g,y=T*p-E*h,(R=Math.hypot(d,v,y))?(d*=R=1/R,v*=R,y*=R):(d=0,v=0,y=0),c[0]=h,c[1]=d,c[2]=T,c[3]=0,c[4]=p,c[5]=v,c[6]=E,c[7]=0,c[8]=g,c[9]=y,c[10]=b,c[11]=0,c[12]=-(h*w+p*A+g*S),c[13]=-(d*w+v*A+y*S),c[14]=-(T*w+E*A+b*S),c[15]=1),function(e,t){var r=t[0],n=t[1],s=t[2],i=t[3],o=t[4],a=t[5],c=t[6],u=t[7],l=t[8],f=t[9],h=t[10],p=t[11],g=t[12],d=t[13],m=t[14],x=t[15],v=r*a-n*o,y=r*c-s*o,T=r*u-i*o,E=n*c-s*a,b=n*u-i*a,R=s*u-i*c,w=l*d-f*g,A=l*m-h*g,S=l*x-p*g,M=f*m-h*d,I=f*x-p*d,C=h*x-p*m,N=v*C-y*I+T*M+E*S-b*A+R*w;N&&(N=1/N,e[0]=(a*C-c*I+u*M)*N,e[1]=(c*S-o*C-u*A)*N,e[2]=(o*I-a*S+u*w)*N,e[3]=(s*I-n*C-i*M)*N,e[4]=(r*C-s*S+i*A)*N,e[5]=(n*S-r*I-i*w)*N,e[6]=(d*R-m*b+x*E)*N,e[7]=(m*T-g*R-x*y)*N,e[8]=(g*b-d*T+x*v)*N)}(i,function(e,t){var r=t[0],n=t[1],s=t[2],i=t[3],o=t[4],a=t[5],c=t[6],u=t[7],l=t[8],f=t[9],h=t[10],p=t[11],g=t[12],d=t[13],m=t[14],x=t[15],v=r*a-n*o,y=r*c-s*o,T=r*u-i*o,E=n*c-s*a,b=n*u-i*a,R=s*u-i*c,w=l*d-f*g,A=l*m-h*g,S=l*x-p*g,M=f*m-h*d,I=f*x-p*d,C=h*x-p*m,N=v*C-y*I+T*M+E*S-b*A+R*w;return N?(N=1/N,e[0]=(a*C-c*I+u*M)*N,e[1]=(s*I-n*C-i*M)*N,e[2]=(d*R-m*b+x*E)*N,e[3]=(h*b-f*R-p*E)*N,e[4]=(c*S-o*C-u*A)*N,e[5]=(r*C-s*S+i*A)*N,e[6]=(m*T-g*R-x*y)*N,e[7]=(l*R-h*T+p*y)*N,e[8]=(o*I-a*S+u*w)*N,e[9]=(n*S-r*I-i*w)*N,e[10]=(g*b-d*T+x*v)*N,e[11]=(f*T-l*b-p*v)*N,e[12]=(a*A-o*M-c*w)*N,e[13]=(r*M-n*A+s*w)*N,e[14]=(d*y-g*E-m*v)*N,e[15]=(l*E-f*y+h*v)*N,e):null}(x,s)),t.queue.writeBuffer(r,64,n)}}var y="const PI : f32 = 3.141592653589793;\n\nfn rotateX(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    1, 0, 0,\n    0, c, s,\n    0, -s, c,\n  );\n}\n\nfn rotateY(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c,\n  );\n}\n\nfn rotateZ(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, s, 0,\n    -s, c, 0,\n    0, 0, 1,\n  );\n}\n";class T{constructor({device:e,format:t}){this.device=e,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},this.effects=(e=>{const t=new Float32Array([0,0,0,.3,.5,.5]),r=e.createBuffer({size:32,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,mappedAtCreation:!0});return new Float32Array(r.getMappedRange()).set(t),r.unmap(),{buffer:r,edges:{get color(){return t.subarray(0,3)},set color(n){t.set(n),e.queue.writeBuffer(r,0,t,0,3)},get intensity(){return t[3]},set intensity(n){t[3]=n,e.queue.writeBuffer(r,12,t,3,1)},get depthScale(){return t[4]},set depthScale(n){t[4]=n,e.queue.writeBuffer(r,16,t,4,1)},get normalScale(){return t[5]},set normalScale(n){t[5]=n,e.queue.writeBuffer(r,20,t,5,1)}}}})(e),this.geometry=(e=>{const t=e.createBuffer({size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(t.getMappedRange()).set([-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1]),t.unmap(),t})(e),this.pipeline=e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:"\n@vertex\nfn main(@location(0) position : vec4<f32>) -> @builtin(position) vec4<f32> {\n  return position;\n}\n"}),entryPoint:"main",buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]}]},fragment:{module:e.createShaderModule({code:"\nstruct Edges {\n  color : vec3<f32>,\n  intensity : f32,\n  depthScale : f32,\n  normalScale : f32,\n}\n\nstruct Effects {\n  edges : Edges,\n}\n\n@group(0) @binding(0) var<uniform> effects : Effects;\n@group(0) @binding(1) var colorTexture : texture_2d<f32>;\n@group(0) @binding(2) var normalTexture : texture_2d<f32>;\n@group(0) @binding(3) var positionTexture : texture_2d<f32>;\n\nconst offset : vec3<i32> = vec3<i32>(1, 1, 0);\n\nfn edgesDepth(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : f32 = textureLoad(positionTexture, pixel, 0).z;\n  var pixelLeft : f32 = textureLoad(positionTexture, pixel - offset.xz, 0).z;\n  var pixelRight : f32 = textureLoad(positionTexture, pixel + offset.xz, 0).z;\n  var pixelUp : f32 = textureLoad(positionTexture, pixel + offset.zy, 0).z;\n  var pixelDown : f32 = textureLoad(positionTexture, pixel - offset.zy, 0).z;\n  return (\n    abs(pixelLeft    - pixelCenter) \n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter) \n  ) * effects.edges.depthScale;\n}\n\nfn edgesNormal(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : vec3<f32> = textureLoad(normalTexture, pixel, 0).xyz;\n  var pixelLeft : vec3<f32> = textureLoad(normalTexture, pixel - offset.xz, 0).xyz;\n  var pixelRight : vec3<f32> = textureLoad(normalTexture, pixel + offset.xz, 0).xyz;\n  var pixelUp : vec3<f32> = textureLoad(normalTexture, pixel + offset.zy, 0).xyz;\n  var pixelDown : vec3<f32> = textureLoad(normalTexture, pixel - offset.zy, 0).xyz;\n  var edge : vec3<f32> = (\n    abs(pixelLeft    - pixelCenter)\n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter)\n  );\n  return (edge.x + edge.y + edge.z) * effects.edges.normalScale;\n}\n\n@fragment\nfn main(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  var pixel : vec2<i32> = vec2<i32>(floor(uv.xy));\n  var color : vec3<f32> = textureLoad(colorTexture, pixel, 0).xyz;\n  if (effects.edges.intensity != 0) {\n    color = mix(color, effects.edges.color, clamp(max(edgesDepth(pixel), edgesNormal(pixel)), 0, 1) * effects.edges.intensity);\n  }\n  return vec4<f32>(color, 1);\n}\n"}),entryPoint:"main",targets:[{format:t}]},primitive:{topology:"triangle-list"}})}bindTextures({color:e,normal:t,position:r}){const{device:n,effects:s,pipeline:i}=this;this.bindings=n.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:s.buffer}},{binding:1,resource:e},{binding:2,resource:t},{binding:3,resource:r}]})}render(e,t){const{bindings:r,descriptor:n,geometry:s,pipeline:i}=this;n.colorAttachments[0].view=t;const o=e.beginRenderPass(n);o.setPipeline(i),o.setBindGroup(0,r),o.setVertexBuffer(0,s),o.draw(6,1,0,0),o.end()}}const E=`\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) face : vec4<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) viewPosition: vec3<f32>,\n  @location(1) normal: vec3<f32>,\n  @location(2) uv: vec2<f32>,\n  @location(3) @interpolate(flat) texture: i32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n  normal : mat3x3<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n${y}\n\nconst faceNormal : vec3<f32> = vec3<f32>(0, 0, 1);\n\n@vertex\nfn main(voxel : VertexInput) -> VertexOutput {\n  var rotation : mat3x3<f32>;\n  switch (i32(voxel.face.w % 6)) {\n    default {\n      rotation = mat3x3<f32>(\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1,\n      );\n    }\n    case 1 {\n      rotation = rotateX(PI * -0.5);\n    }\n    case 2 {\n      rotation = rotateX(PI * 0.5);\n    }\n    case 3 {\n      rotation = rotateY(PI * -0.5);\n    }\n    case 4 {\n      rotation = rotateY(PI * 0.5);\n    }\n    case 5 {\n      rotation = rotateY(PI);\n    }\n  }\n  var mvPosition : vec4<f32> = camera.view * vec4<f32>(rotation * voxel.position + voxel.face.xyz, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.viewPosition = -mvPosition.xyz;\n  out.normal = normalize(camera.normal * rotation * faceNormal);\n  out.uv = voxel.uv;\n  out.texture = i32(floor(voxel.face.w / 6));\n  return out;\n}\n`,b=e=>{const t=e.createBuffer({size:30*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(t.getMappedRange()).set([-.5,-.5,.5,0,1,.5,-.5,.5,1,1,.5,.5,.5,1,0,.5,.5,.5,1,0,-.5,.5,.5,0,0,-.5,-.5,.5,0,1]),t.unmap(),t};class R{constructor({adapter:e,device:t,atlas:r=null,camera:n=null,canvas:s=null,samples:i=4}){const o=navigator.gpu.getPreferredCanvasFormat(e);this.atlas=r||new d({device:t}),this.camera=n||new v({device:t}),this.canvas=s||document.createElement("canvas"),this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight,this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:t,format:o}),this.device=t,this.samples=i;const a=t.createRenderPipeline({layout:"auto",vertex:{module:t.createShaderModule({code:E}),entryPoint:"main",buffers:[{arrayStride:5*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]},{arrayStride:4*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x4"}]}]},fragment:{module:t.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>,\n  @location(3) @interpolate(flat) texture : i32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) normal : vec4<f32>,\n  @location(2) position : vec4<f32>,\n}\n\n@group(0) @binding(1) var atlas : texture_2d_array<f32>;\n@group(0) @binding(2) var atlasSampler : sampler;\n\n@fragment\nfn main(face : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = textureSample(atlas, atlasSampler, face.uv, face.texture);\n  output.normal = vec4<f32>(normalize(face.normal), 1);\n  output.position = vec4<f32>(face.position, 1);\n  return output;\n}\n"}),entryPoint:"main",targets:[{format:"rgba8unorm"},{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:this.samples}});this.rendering={bindings:t.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.camera.buffer}},{binding:1,resource:this.atlas.texture.createView()},{binding:2,resource:t.createSampler()}]}),descriptor:{colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},geometry:b(t),pipeline:a},this.postprocessing=new T({device:t,format:o})}render(e,t){const{context:r,postprocessing:n,rendering:{bindings:s,descriptor:i,geometry:o,pipeline:a}}=this,c=e.beginRenderPass(i);c.setPipeline(a),c.setBindGroup(0,s),c.setVertexBuffer(0,o),t.chunks.forEach((({faces:e})=>{c.setVertexBuffer(1,e,16),c.drawIndirect(e,0)})),c.end(),n.render(e,r.getCurrentTexture().createView())}setClearColor(e,t,r){const{rendering:{descriptor:{colorAttachments:[{clearValue:n}]}}}=this;n.r=e,n.g=t,n.b=r}setSize(e,t){const{camera:r,canvas:n,device:s,postprocessing:i,rendering:o,samples:a}=this,c=window.devicePixelRatio||1,u=[Math.floor(e*c),Math.floor(t*c)];n.width=u[0],n.height=u[1],n.style.width=`${e}px`,n.style.height=`${t}px`,r.aspect=e/t,r.updateProjection();const l=(e,t,r,n)=>(e[t]&&e[t].destroy(),e[t]=s.createTexture({size:u,sampleCount:r,format:n,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),e[t].createView());o.descriptor.colorAttachments[0].view=l(o,"colorTexture",a,"rgba8unorm"),o.descriptor.colorAttachments[0].resolveTarget=l(o,"colorTarget",1,"rgba8unorm"),o.descriptor.colorAttachments[1].view=l(o,"normalTexture",a,"rgba16float"),o.descriptor.colorAttachments[1].resolveTarget=l(o,"normalTarget",1,"rgba16float"),o.descriptor.colorAttachments[2].view=l(o,"positionTexture",a,"rgba16float"),o.descriptor.colorAttachments[2].resolveTarget=l(o,"positionTarget",1,"rgba16float"),o.descriptor.depthStencilAttachment.view=l(o,"depthTexture",a,"depth24plus"),i.bindTextures({color:o.colorTarget.createView(),normal:o.normalTarget.createView(),position:o.positionTarget.createView()})}}class w{constructor(){this._listeners={}}addEventListener(e,t){const r=this._listeners;return void 0===r[e]&&(r[e]=[]),-1===r[e].indexOf(t)&&r[e].push(t),this}removeEventListener(e,t){if(void 0===this._listeners)return this;const r=this._listeners[e];if(void 0!==r){const e=r.indexOf(t);-1!==e&&r.splice(e,1)}return this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){const r=t.slice(0);for(let t=0,n=r.length;t<n;t++)r[t].call(this,e)}return this}dispose(){for(const e in this._listeners)delete this._listeners[e]}}class A extends w{constructor(e,t,r,n={}){if(super(),this._name=void 0,this._parent=void 0,this._child=void 0,this._attributes=void 0,this._disposed=!1,this._name=e,this._parent=t,this._child=r,this._attributes=n,!t.isOnGraph(r))throw new Error("Cannot connect disconnected graphs.")}getName(){return this._name}getParent(){return this._parent}getChild(){return this._child}setChild(e){return this._child=e,this}getAttributes(){return this._attributes}dispose(){this._disposed||(this._disposed=!0,this.dispatchEvent({type:"dispose",target:this}),super.dispose())}isDisposed(){return this._disposed}}class S extends w{constructor(...e){super(...e),this._emptySet=new Set,this._edges=new Set,this._parentEdges=new Map,this._childEdges=new Map}listEdges(){return Array.from(this._edges)}listParentEdges(e){return Array.from(this._childEdges.get(e)||this._emptySet)}listParents(e){return this.listParentEdges(e).map((e=>e.getParent()))}listChildEdges(e){return Array.from(this._parentEdges.get(e)||this._emptySet)}listChildren(e){return this.listChildEdges(e).map((e=>e.getChild()))}disconnectParents(e,t){let r=this.listParentEdges(e);return t&&(r=r.filter((e=>t(e.getParent())))),r.forEach((e=>e.dispose())),this}createEdge(e,t,r,n){return this._registerEdge(new A(e,t,r,n))}_registerEdge(e){this._edges.add(e);const t=e.getParent();this._parentEdges.has(t)||this._parentEdges.set(t,new Set),this._parentEdges.get(t).add(e);const r=e.getChild();return this._childEdges.has(r)||this._childEdges.set(r,new Set),this._childEdges.get(r).add(e),e.addEventListener("dispose",(()=>this._removeEdge(e))),e}_removeEdge(e){return this._edges.delete(e),this._parentEdges.get(e.getParent()).delete(e),this._childEdges.get(e.getChild()).delete(e),this}}function M(){return M=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},M.apply(this,arguments)}function I(e){return e instanceof A}function C(e){return Array.isArray(e)&&e[0]instanceof A}function N(e){return!!(e&&"object"==typeof e&&Object.values(e)[0]instanceof A)}const z=Symbol("attributes"),B=Symbol("immutableKeys");class _ extends w{constructor(e){super(),this._disposed=!1,this.graph=void 0,this[z]=void 0,this[B]=void 0,this.graph=e,this[B]=new Set,this[z]=this._createAttributes()}getDefaults(){return{}}_createAttributes(){const e=this.getDefaults(),t={};for(const r in e){const n=e[r];if(n instanceof _){const e=this.graph.createEdge(r,this,n);e.addEventListener("dispose",(()=>n.dispose())),this[B].add(r),t[r]=e}else t[r]=n}return t}isOnGraph(e){return this.graph===e.graph}isDisposed(){return this._disposed}dispose(){this._disposed||(this.graph.listChildEdges(this).forEach((e=>e.dispose())),this.graph.disconnectParents(this),this._disposed=!0,this.dispatchEvent({type:"dispose"}))}detach(){return this.graph.disconnectParents(this),this}swap(e,t){for(const r in this[z]){const n=this[z][r];if(I(n)){const s=n;s.getChild()===e&&this.setRef(r,t,s.getAttributes())}else if(C(n)){const s=n.find((t=>t.getChild()===e));if(s){const n=s.getAttributes();this.removeRef(r,e).addRef(r,t,n)}}else if(N(n)){const s=n;for(const n in s){const i=s[n];i.getChild()===e&&this.setRefMap(r,n,t,i.getAttributes())}}}return this}get(e){return this[z][e]}set(e,t){return this[z][e]=t,this.dispatchEvent({type:"change",attribute:e})}getRef(e){const t=this[z][e];return t?t.getChild():null}setRef(e,t,r){if(this[B].has(e))throw new Error(`Cannot overwrite immutable attribute, "${e}".`);const n=this[z][e];if(n&&n.dispose(),!t)return this;const s=this.graph.createEdge(e,this,t,r);return s.addEventListener("dispose",(()=>{delete this[z][e],this.dispatchEvent({type:"change",attribute:e})})),this[z][e]=s,this.dispatchEvent({type:"change",attribute:e})}listRefs(e){return this[z][e].map((e=>e.getChild()))}addRef(e,t,r){const n=this.graph.createEdge(e,this,t,r),s=this[z][e];return s.push(n),n.addEventListener("dispose",(()=>{const t=s.filter((e=>e!==n));s.length=0;for(const e of t)s.push(e);this.dispatchEvent({type:"change",attribute:e})})),this.dispatchEvent({type:"change",attribute:e})}removeRef(e,t){return this[z][e].filter((e=>e.getChild()===t)).forEach((e=>e.dispose())),this}listRefMapKeys(e){return Object.keys(this[z][e])}listRefMapValues(e){return Object.values(this[z][e]).map((e=>e.getChild()))}getRefMap(e,t){const r=this[z][e];return r[t]?r[t].getChild():null}setRefMap(e,t,r,n){const s=this[z][e],i=s[t];if(i&&i.dispose(),!r)return this;n=Object.assign(n||{},{key:t});const o=this.graph.createEdge(e,this,r,M({},n,{key:t}));return o.addEventListener("dispose",(()=>{delete s[t],this.dispatchEvent({type:"change",attribute:e,key:t})})),s[t]=o,this.dispatchEvent({type:"change",attribute:e,key:t})}dispatchEvent(e){return super.dispatchEvent(M({},e,{target:this})),this.graph.dispatchEvent(M({},e,{target:this,type:`node:${e.type}`})),this}}var F,U,O,P,L;!function(e){e.ACCESSOR="Accessor",e.ANIMATION="Animation",e.ANIMATION_CHANNEL="AnimationChannel",e.ANIMATION_SAMPLER="AnimationSampler",e.BUFFER="Buffer",e.CAMERA="Camera",e.MATERIAL="Material",e.MESH="Mesh",e.PRIMITIVE="Primitive",e.PRIMITIVE_TARGET="PrimitiveTarget",e.NODE="Node",e.ROOT="Root",e.SCENE="Scene",e.SKIN="Skin",e.TEXTURE="Texture",e.TEXTURE_INFO="TextureInfo"}(F||(F={})),function(e){e.INTERLEAVED="interleaved",e.SEPARATE="separate"}(U||(U={})),function(e){e.ARRAY_BUFFER="ARRAY_BUFFER",e.ELEMENT_ARRAY_BUFFER="ELEMENT_ARRAY_BUFFER",e.INVERSE_BIND_MATRICES="INVERSE_BIND_MATRICES",e.OTHER="OTHER"}(O||(O={})),function(e){e[e.R=4096]="R",e[e.G=256]="G",e[e.B=16]="B",e[e.A=1]="A"}(P||(P={})),function(e){e.GLTF="GLTF",e.GLB="GLB"}(L||(L={}));class D{static createBufferFromDataURI(e){if("undefined"==typeof Buffer){const t=atob(e.split(",")[1]),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r}{const t=e.split(",")[1],r=e.indexOf("base64")>=0;return Buffer.from(t,r?"base64":"utf8")}}static encodeText(e){return"undefined"!=typeof TextEncoder?(new TextEncoder).encode(e):Buffer.from(e)}static decodeText(e){return"undefined"!=typeof TextDecoder?(new TextDecoder).decode(e):Buffer.from(e).toString("utf8")}static concat(e){let t=0;for(const r of e)t+=r.byteLength;const r=new Uint8Array(t);let n=0;for(const t of e)r.set(t,n),n+=t.byteLength;return r}static pad(e,t=0){const r=this.padNumber(e.byteLength);if(r===e.byteLength)return e;const n=new Uint8Array(r);if(n.set(e),0!==t)for(let s=e.byteLength;s<r;s++)n[s]=t;return n}static padNumber(e){return 4*Math.ceil(e/4)}static equals(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;let r=e.byteLength;for(;r--;)if(e[r]!==t[r])return!1;return!0}static toView(e,t=0,r=1/0){return new Uint8Array(e.buffer,e.byteOffset+t,Math.min(e.byteLength,r))}static assertView(e){if(e&&!ArrayBuffer.isView(e))throw new Error(`Method requires Uint8Array parameter; received "${typeof e}".`);return e}}class V{static hexToFactor(e,t){e=Math.floor(e);const r=t;return r[0]=(e>>16&255)/255,r[1]=(e>>8&255)/255,r[2]=(255&e)/255,this.convertSRGBToLinear(t,t)}static factorToHex(e){const t=[...e],[r,n,s]=this.convertLinearToSRGB(e,t);return 255*r<<16^255*n<<8^255*s<<0}static convertSRGBToLinear(e,t){const r=e,n=t;for(let e=0;e<3;e++)n[e]=r[e]<.04045?.0773993808*r[e]:Math.pow(.9478672986*r[e]+.0521327014,2.4);return t}static convertLinearToSRGB(e,t){const r=e,n=t;for(let e=0;e<3;e++)n[e]=r[e]<.0031308?12.92*r[e]:1.055*Math.pow(r[e],.41666)-.055;return t}}class k{match(e){return e.length>=8&&137===e[0]&&80===e[1]&&78===e[2]&&71===e[3]&&13===e[4]&&10===e[5]&&26===e[6]&&10===e[7]}getSize(e){const t=new DataView(e.buffer,e.byteOffset);return D.decodeText(e.slice(12,16))===k.PNG_FRIED_CHUNK_NAME?[t.getUint32(32,!1),t.getUint32(36,!1)]:[t.getUint32(16,!1),t.getUint32(20,!1)]}getChannels(e){return 4}}k.PNG_FRIED_CHUNK_NAME="CgBI";class G{static registerFormat(e,t){this.impls[e]=t}static getMimeType(e){for(const t in this.impls)if(this.impls[t].match(e))return t;return null}static getSize(e,t){return this.impls[t]?this.impls[t].getSize(e):null}static getChannels(e,t){return this.impls[t]?this.impls[t].getChannels(e):null}static getMemSize(e,t){if(!this.impls[t])return null;if(this.impls[t].getGPUByteLength)return this.impls[t].getGPUByteLength(e);let r=0;const n=this.getSize(e,t);if(!n)return null;for(;n[0]>1||n[1]>1;)r+=n[0]*n[1]*4,n[0]=Math.max(Math.floor(n[0]/2),1),n[1]=Math.max(Math.floor(n[1]/2),1);return r+=4,r}static mimeTypeToExtension(e){return"image/jpeg"===e?"jpg":e.split("/").pop()}static extensionToMimeType(e){return"jpg"===e?"image/jpeg":`image/${e}`}}function j(e,t){if(t>e.byteLength)throw new TypeError("Corrupt JPG, exceeded buffer limits");if(255!==e.getUint8(t))throw new TypeError("Invalid JPG, marker table corrupted");return e}G.impls={"image/jpeg":new class{match(e){return e.length>=3&&255===e[0]&&216===e[1]&&255===e[2]}getSize(e){let t,r,n=new DataView(e.buffer,e.byteOffset+4);for(;n.byteLength;){if(t=n.getUint16(0,!1),j(n,t),r=n.getUint8(t+1),192===r||193===r||194===r)return[n.getUint16(t+7,!1),n.getUint16(t+5,!1)];n=new DataView(e.buffer,n.byteOffset+t+2)}throw new TypeError("Invalid JPG, no size found")}getChannels(e){return 3}},"image/png":new k};class q{static basename(e){const t=e.split(/[\\/]/).pop();return t.substring(0,t.lastIndexOf("."))}static extension(e){if(e.startsWith("data:image/")){const t=e.match(/data:(image\/\w+)/)[1];return G.mimeTypeToExtension(t)}return e.startsWith("data:model/gltf+json")?"gltf":e.startsWith("data:model/gltf-binary")?"glb":e.startsWith("data:application/")?"bin":e.split(/[\\/]/).pop().split(/[.]/).pop()}}function Y(e){return"[object Object]"===Object.prototype.toString.call(e)}function $(e){if(!1===Y(e))return!1;const t=e.constructor;if(void 0===t)return!0;const r=t.prototype;return!1!==Y(r)&&!1!==Object.prototype.hasOwnProperty.call(r,"isPrototypeOf")}class W{constructor(e){this.verbosity=void 0,this.verbosity=e}debug(e){this.verbosity<=W.Verbosity.DEBUG&&console.debug(e)}info(e){this.verbosity<=W.Verbosity.INFO&&console.info(e)}warn(e){this.verbosity<=W.Verbosity.WARN&&console.warn(e)}error(e){this.verbosity<=W.Verbosity.ERROR&&console.error(e)}}W.Verbosity={SILENT:4,ERROR:3,WARN:2,INFO:1,DEBUG:0},W.DEFAULT_INSTANCE=new W(W.Verbosity.INFO);class H{static identity(e){return e}static eq(e,t){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(Math.abs(e[r]-t[r])>1e-5)return!1;return!0}static denormalize(e,t){switch(t){case 5126:return e;case 5123:return e/65535;case 5121:return e/255;case 5122:return Math.max(e/32767,-1);case 5120:return Math.max(e/127,-1);default:throw new Error("Invalid component type.")}}static normalize(e,t){switch(t){case 5126:return e;case 5123:return Math.round(65535*e);case 5121:return Math.round(255*e);case 5122:return Math.round(32767*e);case 5120:return Math.round(127*e);default:throw new Error("Invalid component type.")}}static decompose(e,t,r,n){let s=u([e[0],e[1],e[2]]);const o=u([e[4],e[5],e[6]]),a=u([e[8],e[9],e[10]]);(function(e){var t=e[0],r=e[1],n=e[2],s=e[3],i=e[4],o=e[5],a=e[6],c=e[7],u=e[8],l=e[9],f=e[10],h=e[11],p=e[12],g=e[13],d=e[14],m=e[15];return(t*o-r*i)*(f*m-h*d)-(t*a-n*i)*(l*m-h*g)+(t*c-s*i)*(l*d-f*g)+(r*a-n*o)*(u*m-h*p)-(r*c-s*o)*(u*d-f*p)+(n*c-s*a)*(u*g-l*p)})(e)<0&&(s=-s),t[0]=e[12],t[1]=e[13],t[2]=e[14];const c=e.slice(),l=1/s,f=1/o,h=1/a;c[0]*=l,c[1]*=l,c[2]*=l,c[4]*=f,c[5]*=f,c[6]*=f,c[8]*=h,c[9]*=h,c[10]*=h,i(r,c),n[0]=s,n[1]=o,n[2]=a}static compose(e,t,r,n){const s=n,i=t[0],o=t[1],a=t[2],c=t[3],u=i+i,l=o+o,f=a+a,h=i*u,p=i*l,g=i*f,d=o*l,m=o*f,x=a*f,v=c*u,y=c*l,T=c*f,E=r[0],b=r[1],R=r[2];return s[0]=(1-(d+x))*E,s[1]=(p+T)*E,s[2]=(g-y)*E,s[3]=0,s[4]=(p-T)*b,s[5]=(1-(h+x))*b,s[6]=(m+v)*b,s[7]=0,s[8]=(g+y)*R,s[9]=(m-v)*R,s[10]=(1-(h+d))*R,s[11]=0,s[12]=e[0],s[13]=e[1],s[14]=e[2],s[15]=1,s}}function J(e,t){if(!!e!=!!t)return!1;const r=e.getChild(),n=t.getChild();return r===n||r.equals(n)}function X(e,t){if(!!e!=!!t)return!1;if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++){const n=e[r],s=t[r];if(n.getChild()!==s.getChild()&&!n.getChild().equals(s.getChild()))return!1}return!0}function Z(e,t){if(!!e!=!!t)return!1;const r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(const r in e){const n=e[r],s=t[r];if(!!n!=!!s)return!1;const i=n.getChild(),o=s.getChild();if(i!==o&&!i.equals(o))return!1}return!0}function K(e,t){if(e===t)return!0;if(!!e!=!!t||!e||!t)return!1;if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}function Q(e,t){if(e===t)return!0;if(!!e!=!!t)return!1;if(!$(e)||!$(t))return e===t;const r=e,n=t;let s,i=0,o=0;for(s in r)i++;for(s in n)o++;if(i!==o)return!1;for(s in r){const e=r[s],t=n[s];if(ee(e)&&ee(t)){if(!K(e,t))return!1}else if($(e)&&$(t)){if(!Q(e,t))return!1}else if(e!==t)return!1}return!0}function ee(e){return Array.isArray(e)||ArrayBuffer.isView(e)}const te="23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ",re=new Set,ne=function(){let e="";for(let t=0;t<6;t++)e+=te.charAt(Math.floor(Math.random()*te.length));return e};class se{static dirname(e){const t=e.lastIndexOf("/");return-1===t?"./":e.substring(0,t+1)}static basename(e){return q.basename(new URL(e,"https://null.example").pathname)}static extension(e){return q.extension(new URL(e,"https://null.example").pathname)}static resolve(e,t){if(!this.isRelativePath(t))return t;const r=e.split("/"),n=t.split("/");r.pop();for(let e=0;e<n.length;e++)"."!==n[e]&&(".."===n[e]?r.pop():r.push(n[e]));return r.join("/")}static isAbsoluteURL(e){return this.PROTOCOL_REGEXP.test(e)}static isRelativePath(e){return!/^(?:[a-zA-Z]+:)?\//.test(e)}}se.DEFAULT_INIT={},se.PROTOCOL_REGEXP=/^[a-zA-Z]+:\/\//;const ie=e=>e,oe=new Set;class ae extends _{constructor(e,t=""){super(e),this[z].name=t,this.init(),this.dispatchEvent({type:"create"})}getDefaults(){return Object.assign(super.getDefaults(),{name:"",extras:{}})}getName(){return this.get("name")}setName(e){return this.set("name",e)}getExtras(){return this.get("extras")}setExtras(e){return this.set("extras",e)}clone(){return new this.constructor(this.graph).copy(this,ie)}copy(e,t=ie){for(const e in this[z]){const t=this[z][e];if(t instanceof A)this[B].has(e)||t.dispose();else if(Array.isArray(t)&&t[0]instanceof A)for(const e of t)e.dispose();else if($(t)&&Object.values(t)[0]instanceof A)for(const e in t)t[e].dispose()}for(const r in e[z]){const n=this[z][r],s=e[z][r];if(s instanceof A)this[B].has(r)?n.getChild().copy(t(s.getChild()),t):this.setRef(r,t(s.getChild()),s.getAttributes());else if(Array.isArray(s)&&s[0]instanceof A)for(const e of s)this.addRef(r,t(e.getChild()),e.getAttributes());else if($(s)&&Object.values(s)[0]instanceof A)for(const e in s){const n=s[e];this.setRefMap(r,e,t(n.getChild()),n.getAttributes())}else this[z][r]=$(s)?JSON.parse(JSON.stringify(s)):Array.isArray(s)||s instanceof ArrayBuffer||ArrayBuffer.isView(s)?s.slice():s}return this}equals(e,t=oe){if(this===e)return!0;if(this.propertyType!==e.propertyType)return!1;for(const r in this[z]){if(t.has(r))continue;const n=this[z][r],s=e[z][r];if(I(n)||I(s)){if(!J(n,s))return!1}else if(C(n)||C(s)){if(!X(n,s))return!1}else if(N(n)||N(s)){if(!Z(n,s))return!1}else if($(n)||$(s)){if(!Q(n,s))return!1}else if(ee(n)||ee(s)){if(!K(n,s))return!1}else if(n!==s)return!1}return!0}detach(){return this.graph.disconnectParents(this,(e=>"Root"!==e.propertyType)),this}listParents(){return this.graph.listParents(this)}}class ce extends ae{getDefaults(){return Object.assign(super.getDefaults(),{extensions:{}})}getExtension(e){return this.getRefMap("extensions",e)}setExtension(e,t){return t&&t.t(this),this.setRefMap("extensions",e,t)}listExtensions(){return this.listRefMapValues("extensions")}}class ue extends ce{constructor(...e){super(...e),this.i=H.identity,this.o=H.identity}init(){this.propertyType=F.ACCESSOR}getDefaults(){return Object.assign(super.getDefaults(),{array:null,type:ue.Type.SCALAR,componentType:ue.ComponentType.FLOAT,normalized:!1,buffer:null})}copy(e,t=ie){return super.copy(e,t),this.i=e.i,this.o=e.o,this}static getElementSize(e){switch(e){case ue.Type.SCALAR:return 1;case ue.Type.VEC2:return 2;case ue.Type.VEC3:return 3;case ue.Type.VEC4:case ue.Type.MAT2:return 4;case ue.Type.MAT3:return 9;case ue.Type.MAT4:return 16;default:throw new Error("Unexpected type: "+e)}}static getComponentSize(e){switch(e){case ue.ComponentType.BYTE:case ue.ComponentType.UNSIGNED_BYTE:return 1;case ue.ComponentType.SHORT:case ue.ComponentType.UNSIGNED_SHORT:return 2;case ue.ComponentType.UNSIGNED_INT:case ue.ComponentType.FLOAT:return 4;default:throw new Error("Unexpected component type: "+e)}}getMinNormalized(e){const t=this.getElementSize();this.getMin(e);for(let r=0;r<t;r++)e[r]=this.o(e[r]);return e}getMin(e){const t=this.get("array"),r=this.getCount(),n=this.getElementSize();for(let t=0;t<n;t++)e[t]=1/0;for(let s=0;s<r*n;s+=n)for(let r=0;r<n;r++){const n=t[s+r];Number.isFinite(n)&&(e[r]=Math.min(e[r],n))}return e}getMaxNormalized(e){const t=this.getElementSize();this.getMax(e);for(let r=0;r<t;r++)e[r]=this.o(e[r]);return e}getMax(e){const t=this.get("array"),r=this.getCount(),n=this.getElementSize();for(let t=0;t<n;t++)e[t]=-1/0;for(let s=0;s<r*n;s+=n)for(let r=0;r<n;r++){const n=t[s+r];Number.isFinite(n)&&(e[r]=Math.max(e[r],n))}return e}getCount(){const e=this.get("array");return e?e.length/this.getElementSize():0}getType(){return this.get("type")}setType(e){return this.set("type",e)}getElementSize(){return ue.getElementSize(this.get("type"))}getComponentSize(){return this.get("array").BYTES_PER_ELEMENT}getComponentType(){return this.get("componentType")}getNormalized(){return this.get("normalized")}setNormalized(e){return this.set("normalized",e),e?(this.o=e=>H.denormalize(e,this.get("componentType")),this.i=e=>H.normalize(e,this.get("componentType"))):(this.o=H.identity,this.i=H.identity),this}getScalar(e){const t=this.getElementSize();return this.o(this.get("array")[e*t])}setScalar(e,t){return this.get("array")[e*this.getElementSize()]=this.i(t),this}getElement(e,t){const r=this.getElementSize(),n=this.get("array");for(let s=0;s<r;s++)t[s]=this.o(n[e*r+s]);return t}setElement(e,t){const r=this.getElementSize(),n=this.get("array");for(let s=0;s<r;s++)n[e*r+s]=this.i(t[s]);return this}getBuffer(){return this.getRef("buffer")}setBuffer(e){return this.setRef("buffer",e)}getArray(){return this.get("array")}setArray(e){return this.set("componentType",e?function(e){switch(e.constructor){case Float32Array:return ue.ComponentType.FLOAT;case Uint32Array:return ue.ComponentType.UNSIGNED_INT;case Uint16Array:return ue.ComponentType.UNSIGNED_SHORT;case Uint8Array:return ue.ComponentType.UNSIGNED_BYTE;case Int16Array:return ue.ComponentType.SHORT;case Int8Array:return ue.ComponentType.BYTE;default:throw new Error("Unknown accessor componentType.")}}(e):ue.ComponentType.FLOAT),this.set("array",e),this}getByteLength(){const e=this.get("array");return e?e.byteLength:0}}ue.Type={SCALAR:"SCALAR",VEC2:"VEC2",VEC3:"VEC3",VEC4:"VEC4",MAT2:"MAT2",MAT3:"MAT3",MAT4:"MAT4"},ue.ComponentType={BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,UNSIGNED_INT:5125,FLOAT:5126};class le extends ce{init(){this.propertyType=F.ANIMATION}getDefaults(){return Object.assign(super.getDefaults(),{channels:[],samplers:[]})}addChannel(e){return this.addRef("channels",e)}removeChannel(e){return this.removeRef("channels",e)}listChannels(){return this.listRefs("channels")}addSampler(e){return this.addRef("samplers",e)}removeSampler(e){return this.removeRef("samplers",e)}listSamplers(){return this.listRefs("samplers")}}class fe extends ce{init(){this.propertyType=F.ANIMATION_CHANNEL}getDefaults(){return Object.assign(super.getDefaults(),{targetPath:null,targetNode:null,sampler:null})}getTargetPath(){return this.get("targetPath")}setTargetPath(e){return this.set("targetPath",e)}getTargetNode(){return this.getRef("targetNode")}setTargetNode(e){return this.setRef("targetNode",e)}getSampler(){return this.getRef("sampler")}setSampler(e){return this.setRef("sampler",e)}}fe.TargetPath={TRANSLATION:"translation",ROTATION:"rotation",SCALE:"scale",WEIGHTS:"weights"};class he extends ce{init(){this.propertyType=F.ANIMATION_SAMPLER}getDefaultAttributes(){return Object.assign(super.getDefaults(),{interpolation:he.Interpolation.LINEAR,input:null,output:null})}getInterpolation(){return this.get("interpolation")}setInterpolation(e){return this.set("interpolation",e)}getInput(){return this.getRef("input")}setInput(e){return this.setRef("input",e,{usage:O.OTHER})}getOutput(){return this.getRef("output")}setOutput(e){return this.setRef("output",e,{usage:O.OTHER})}}he.Interpolation={LINEAR:"LINEAR",STEP:"STEP",CUBICSPLINE:"CUBICSPLINE"};class pe extends ce{init(){this.propertyType=F.BUFFER}getDefaults(){return Object.assign(super.getDefaults(),{uri:""})}getURI(){return this.get("uri")}setURI(e){return this.set("uri",e)}}class ge extends ce{init(){this.propertyType=F.CAMERA}getDefaults(){return Object.assign(super.getDefaults(),{type:ge.Type.PERSPECTIVE,znear:.1,zfar:100,aspectRatio:null,yfov:2*Math.PI*50/360,xmag:1,ymag:1})}getType(){return this.get("type")}setType(e){return this.set("type",e)}getZNear(){return this.get("znear")}setZNear(e){return this.set("znear",e)}getZFar(){return this.get("zfar")}setZFar(e){return this.set("zfar",e)}getAspectRatio(){return this.get("aspectRatio")}setAspectRatio(e){return this.set("aspectRatio",e)}getYFov(){return this.get("yfov")}setYFov(e){return this.set("yfov",e)}getXMag(){return this.get("xmag")}setXMag(e){return this.set("xmag",e)}getYMag(){return this.get("ymag")}setYMag(e){return this.set("ymag",e)}}ge.Type={PERSPECTIVE:"perspective",ORTHOGRAPHIC:"orthographic"};(class extends ae{t(e){if(!this.parentTypes.includes(e.propertyType))throw new Error(`Parent "${e.propertyType}" invalid for child "${this.propertyType}".`)}}).EXTENSION_NAME=void 0;class de extends ce{init(){this.propertyType=F.TEXTURE_INFO}getDefaults(){return Object.assign(super.getDefaults(),{texCoord:0,magFilter:null,minFilter:null,wrapS:de.WrapMode.REPEAT,wrapT:de.WrapMode.REPEAT})}getTexCoord(){return this.get("texCoord")}setTexCoord(e){return this.set("texCoord",e)}getMagFilter(){return this.get("magFilter")}setMagFilter(e){return this.set("magFilter",e)}getMinFilter(){return this.get("minFilter")}setMinFilter(e){return this.set("minFilter",e)}getWrapS(){return this.get("wrapS")}setWrapS(e){return this.set("wrapS",e)}getWrapT(){return this.get("wrapT")}setWrapT(e){return this.set("wrapT",e)}}de.WrapMode={CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},de.MagFilter={NEAREST:9728,LINEAR:9729},de.MinFilter={NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987};const{R:me,G:xe,B:ve,A:ye}=P;class Te extends ce{init(){this.propertyType=F.MATERIAL}getDefaults(){return Object.assign(super.getDefaults(),{alphaMode:Te.AlphaMode.OPAQUE,alphaCutoff:.5,doubleSided:!1,baseColorFactor:[1,1,1,1],baseColorTexture:null,baseColorTextureInfo:new de(this.graph,"baseColorTextureInfo"),emissiveFactor:[0,0,0],emissiveTexture:null,emissiveTextureInfo:new de(this.graph,"emissiveTextureInfo"),normalScale:1,normalTexture:null,normalTextureInfo:new de(this.graph,"normalTextureInfo"),occlusionStrength:1,occlusionTexture:null,occlusionTextureInfo:new de(this.graph,"occlusionTextureInfo"),roughnessFactor:1,metallicFactor:1,metallicRoughnessTexture:null,metallicRoughnessTextureInfo:new de(this.graph,"metallicRoughnessTextureInfo")})}getDoubleSided(){return this.get("doubleSided")}setDoubleSided(e){return this.set("doubleSided",e)}getAlpha(){return this.get("baseColorFactor")[3]}setAlpha(e){const t=this.get("baseColorFactor").slice();return t[3]=e,this.set("baseColorFactor",t)}getAlphaMode(){return this.get("alphaMode")}setAlphaMode(e){return this.set("alphaMode",e)}getAlphaCutoff(){return this.get("alphaCutoff")}setAlphaCutoff(e){return this.set("alphaCutoff",e)}getBaseColorFactor(){return this.get("baseColorFactor")}setBaseColorFactor(e){return this.set("baseColorFactor",e)}getBaseColorHex(){return V.factorToHex(this.get("baseColorFactor"))}setBaseColorHex(e){const t=this.get("baseColorFactor").slice();return this.set("baseColorFactor",V.hexToFactor(e,t))}getBaseColorTexture(){return this.getRef("baseColorTexture")}getBaseColorTextureInfo(){return this.getRef("baseColorTexture")?this.getRef("baseColorTextureInfo"):null}setBaseColorTexture(e){return this.setRef("baseColorTexture",e,{channels:me|xe|ve|ye})}getEmissiveFactor(){return this.get("emissiveFactor")}setEmissiveFactor(e){return this.set("emissiveFactor",e)}getEmissiveHex(){return V.factorToHex(this.get("emissiveFactor"))}setEmissiveHex(e){const t=this.get("emissiveFactor").slice();return this.set("emissiveFactor",V.hexToFactor(e,t))}getEmissiveTexture(){return this.getRef("emissiveTexture")}getEmissiveTextureInfo(){return this.getRef("emissiveTexture")?this.getRef("emissiveTextureInfo"):null}setEmissiveTexture(e){return this.setRef("emissiveTexture",e,{channels:me|xe|ve})}getNormalScale(){return this.get("normalScale")}setNormalScale(e){return this.set("normalScale",e)}getNormalTexture(){return this.getRef("normalTexture")}getNormalTextureInfo(){return this.getRef("normalTexture")?this.getRef("normalTextureInfo"):null}setNormalTexture(e){return this.setRef("normalTexture",e,{channels:me|xe|ve})}getOcclusionStrength(){return this.get("occlusionStrength")}setOcclusionStrength(e){return this.set("occlusionStrength",e)}getOcclusionTexture(){return this.getRef("occlusionTexture")}getOcclusionTextureInfo(){return this.getRef("occlusionTexture")?this.getRef("occlusionTextureInfo"):null}setOcclusionTexture(e){return this.setRef("occlusionTexture",e,{channels:me})}getRoughnessFactor(){return this.get("roughnessFactor")}setRoughnessFactor(e){return this.set("roughnessFactor",e)}getMetallicFactor(){return this.get("metallicFactor")}setMetallicFactor(e){return this.set("metallicFactor",e)}getMetallicRoughnessTexture(){return this.getRef("metallicRoughnessTexture")}getMetallicRoughnessTextureInfo(){return this.getRef("metallicRoughnessTexture")?this.getRef("metallicRoughnessTextureInfo"):null}setMetallicRoughnessTexture(e){return this.setRef("metallicRoughnessTexture",e,{channels:xe|ve})}}Te.AlphaMode={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};class Ee extends ce{init(){this.propertyType=F.MESH}getDefaults(){return Object.assign(super.getDefaults(),{weights:[],primitives:[]})}addPrimitive(e){return this.addRef("primitives",e)}removePrimitive(e){return this.removeRef("primitives",e)}listPrimitives(){return this.listRefs("primitives")}getWeights(){return this.get("weights")}setWeights(e){return this.set("weights",e)}}class be extends ce{constructor(...e){super(...e),this.u=null}init(){this.propertyType=F.NODE}getDefaults(){return Object.assign(super.getDefaults(),{translation:[0,0,0],rotation:[0,0,0,1],scale:[1,1,1],weights:[],camera:null,mesh:null,skin:null,children:[]})}copy(e,t=ie){if(t===ie)throw new Error("Node cannot be copied.");return super.copy(e,t)}getTranslation(){return this.get("translation")}getRotation(){return this.get("rotation")}getScale(){return this.get("scale")}setTranslation(e){return this.set("translation",e)}setRotation(e){return this.set("rotation",e)}setScale(e){return this.set("scale",e)}getMatrix(){return H.compose(this.get("translation"),this.get("rotation"),this.get("scale"),[])}setMatrix(e){const t=this.get("translation").slice(),r=this.get("rotation").slice(),n=this.get("scale").slice();return H.decompose(e,t,r,n),this.set("translation",t).set("rotation",r).set("scale",n)}getWorldTranslation(){const e=[0,0,0];return H.decompose(this.getWorldMatrix(),e,[0,0,0,1],[1,1,1]),e}getWorldRotation(){const e=[0,0,0,1];return H.decompose(this.getWorldMatrix(),[0,0,0],e,[1,1,1]),e}getWorldScale(){const e=[1,1,1];return H.decompose(this.getWorldMatrix(),[0,0,0],[0,0,0,1],e),e}getWorldMatrix(){const e=[];for(let t=this;t instanceof be;t=t.u)e.push(t);let t;const r=e.pop().getMatrix();for(;t=e.pop();)s(r,r,t.getMatrix());return r}addChild(e){e.u&&e.u.removeChild(e),this.addRef("children",e),e.u=this;const t=this[z].children;return t[t.length-1].addEventListener("dispose",(()=>e.u=null)),this}removeChild(e){return this.removeRef("children",e)}listChildren(){return this.listRefs("children")}getParent(){return this.u}getMesh(){return this.getRef("mesh")}setMesh(e){return this.setRef("mesh",e)}getCamera(){return this.getRef("camera")}setCamera(e){return this.setRef("camera",e)}getSkin(){return this.getRef("skin")}setSkin(e){return this.setRef("skin",e)}getWeights(){return this.get("weights")}setWeights(e){return this.set("weights",e)}traverse(e){e(this);for(const t of this.listChildren())t.traverse(e);return this}}class Re extends ce{init(){this.propertyType=F.PRIMITIVE}getDefaults(){return Object.assign(super.getDefaults(),{mode:Re.Mode.TRIANGLES,material:null,indices:null,attributes:{},targets:[]})}getIndices(){return this.getRef("indices")}setIndices(e){return this.setRef("indices",e,{usage:O.ELEMENT_ARRAY_BUFFER})}getAttribute(e){return this.getRefMap("attributes",e)}setAttribute(e,t){return this.setRefMap("attributes",e,t,{usage:O.ARRAY_BUFFER})}listAttributes(){return this.listRefMapValues("attributes")}listSemantics(){return this.listRefMapKeys("attributes")}getMaterial(){return this.getRef("material")}setMaterial(e){return this.setRef("material",e)}getMode(){return this.get("mode")}setMode(e){return this.set("mode",e)}listTargets(){return this.listRefs("targets")}addTarget(e){return this.addRef("targets",e)}removeTarget(e){return this.removeRef("targets",e)}}Re.Mode={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class we extends ae{init(){this.propertyType=F.PRIMITIVE_TARGET}getDefaults(){return Object.assign(super.getDefaults(),{attributes:{}})}getAttribute(e){return this.getRefMap("attributes",e)}setAttribute(e,t){return this.setRefMap("attributes",e,t,{usage:O.ARRAY_BUFFER})}listAttributes(){return this.listRefMapValues("attributes")}listSemantics(){return this.listRefMapKeys("attributes")}}function Ae(){return(Ae=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}class Se extends ce{init(){this.propertyType=F.SCENE}getDefaults(){return Object.assign(super.getDefaults(),{children:[]})}copy(e,t=ie){if(t===ie)throw new Error("Scene cannot be copied.");return super.copy(e,t)}addChild(e){e.u&&e.u.removeChild(e),this.addRef("children",e),e.u=this;const t=this[z].children;return t[t.length-1].addEventListener("dispose",(()=>e.u=null)),this}removeChild(e){return this.removeRef("children",e)}listChildren(){return this.listRefs("children")}traverse(e){for(const t of this.listChildren())t.traverse(e);return this}}class Me extends ce{init(){this.propertyType=F.SKIN}getDefaults(){return Object.assign(super.getDefaults(),{skeleton:null,inverseBindMatrices:null,joints:[]})}getSkeleton(){return this.getRef("skeleton")}setSkeleton(e){return this.setRef("skeleton",e)}getInverseBindMatrices(){return this.getRef("inverseBindMatrices")}setInverseBindMatrices(e){return this.setRef("inverseBindMatrices",e,{usage:O.INVERSE_BIND_MATRICES})}addJoint(e){return this.addRef("joints",e)}removeJoint(e){return this.removeRef("joints",e)}listJoints(){return this.listRefs("joints")}}class Ie extends ce{init(){this.propertyType=F.TEXTURE}getDefaults(){return Object.assign(super.getDefaults(),{image:null,mimeType:"",uri:""})}getMimeType(){return this.get("mimeType")||G.extensionToMimeType(q.extension(this.get("uri")))}setMimeType(e){return this.set("mimeType",e)}getURI(){return this.get("uri")}setURI(e){return this.set("uri",e),this.set("mimeType",G.extensionToMimeType(q.extension(e))),this}getImage(){return this.get("image")}setImage(e){return this.set("image",D.assertView(e))}getSize(){const e=this.get("image");return e?G.getSize(e,this.getMimeType()):null}}class Ce extends ce{init(){this.propertyType=F.ROOT}getDefaults(){return Object.assign(super.getDefaults(),{asset:{generator:"glTF-Transform v2.2.2",version:"2.0"},defaultScene:null,accessors:[],animations:[],buffers:[],cameras:[],materials:[],meshes:[],nodes:[],scenes:[],skins:[],textures:[]})}constructor(e){super(e),this.h=new Set,e.addEventListener("node:create",(e=>{this.l(e.target)}))}clone(){throw new Error("Root cannot be cloned.")}copy(e,t=ie){if(t===ie)throw new Error("Root cannot be copied.");this.set("asset",Ae({},e.get("asset"))),this.setName(e.getName()),this.setExtras(Ae({},e.getExtras())),this.setDefaultScene(e.getDefaultScene()?t(e.getDefaultScene()):null);for(const r of e.listRefMapKeys("extensions")){const n=e.getExtension(r);this.setExtension(r,t(n))}return this}l(e){return e instanceof Se?this.addRef("scenes",e):e instanceof be?this.addRef("nodes",e):e instanceof ge?this.addRef("cameras",e):e instanceof Me?this.addRef("skins",e):e instanceof Ee?this.addRef("meshes",e):e instanceof Te?this.addRef("materials",e):e instanceof Ie?this.addRef("textures",e):e instanceof le?this.addRef("animations",e):e instanceof ue?this.addRef("accessors",e):e instanceof pe&&this.addRef("buffers",e),this}getAsset(){return this.get("asset")}listExtensionsUsed(){return Array.from(this.h)}listExtensionsRequired(){return this.listExtensionsUsed().filter((e=>e.isRequired()))}g(e){return this.h.add(e),this}p(e){return this.h.delete(e),this}listScenes(){return this.listRefs("scenes")}setDefaultScene(e){return this.setRef("defaultScene",e)}getDefaultScene(){return this.getRef("defaultScene")}listNodes(){return this.listRefs("nodes")}listCameras(){return this.listRefs("cameras")}listSkins(){return this.listRefs("skins")}listMeshes(){return this.listRefs("meshes")}listMaterials(){return this.listRefs("materials")}listTextures(){return this.listRefs("textures")}listAnimations(){return this.listRefs("animations")}listAccessors(){return this.listRefs("accessors")}listBuffers(){return this.listRefs("buffers")}}class Ne{constructor(){this.m=new S,this.T=new Ce(this.m),this.v=W.DEFAULT_INSTANCE}getRoot(){return this.T}getGraph(){return this.m}getLogger(){return this.v}setLogger(e){return this.v=e,this}clone(){return(new Ne).setLogger(this.v).merge(this)}merge(e){for(const t of e.getRoot().listExtensionsUsed()){const e=this.createExtension(t.constructor);t.isRequired()&&e.setRequired(!0)}const t=new Set,r=new Map;t.add(e.T),r.set(e.T,this.T);for(const n of e.m.listEdges())for(const e of[n.getParent(),n.getChild()]){if(t.has(e))continue;let n;n=e.propertyType===F.TEXTURE_INFO?e:new e.constructor(this.m),r.set(e,n),t.add(e)}const n=e=>{const t=r.get(e);if(!t)throw new Error("Could resolve property.");return t};for(const e of t){const t=r.get(e);if(!t)throw new Error("Could resolve property.");t.propertyType!==F.TEXTURE_INFO&&t.copy(e,n)}return this}async transform(...e){const t=e.map((e=>e.name));for(const r of e)await r(this,{stack:t});return this}createExtension(e){const t=e.EXTENSION_NAME;return this.getRoot().listExtensionsUsed().find((e=>e.extensionName===t))||new e(this)}createScene(e=""){return new Se(this.m,e)}createNode(e=""){return new be(this.m,e)}createCamera(e=""){return new ge(this.m,e)}createSkin(e=""){return new Me(this.m,e)}createMesh(e=""){return new Ee(this.m,e)}createPrimitive(){return new Re(this.m)}createPrimitiveTarget(e=""){return new we(this.m,e)}createMaterial(e=""){return new Te(this.m,e)}createTexture(e=""){return new Ie(this.m,e)}createAnimation(e=""){return new le(this.m,e)}createAnimationChannel(e=""){return new fe(this.m,e)}createAnimationSampler(e=""){return new he(this.m,e)}createAccessor(e="",t=null){return t||(t=this.getRoot().listBuffers()[0]),new ue(this.m,e).setBuffer(t)}createBuffer(e=""){return new pe(this.m,e)}}class ze{constructor(e){this.jsonDoc=void 0,this.buffers=[],this.bufferViews=[],this.bufferViewBuffers=[],this.accessors=[],this.textures=[],this.textureInfos=new Map,this.materials=[],this.meshes=[],this.cameras=[],this.nodes=[],this.skins=[],this.animations=[],this.scenes=[],this.jsonDoc=e}setTextureInfo(e,t){this.textureInfos.set(e,t),void 0!==t.texCoord&&e.setTexCoord(t.texCoord);const r=this.jsonDoc.json.textures[t.index];if(void 0===r.sampler)return;const n=this.jsonDoc.json.samplers[r.sampler];void 0!==n.magFilter&&e.setMagFilter(n.magFilter),void 0!==n.minFilter&&e.setMinFilter(n.minFilter),void 0!==n.wrapS&&e.setWrapS(n.wrapS),void 0!==n.wrapT&&e.setWrapT(n.wrapT)}}const Be={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},_e={logger:W.DEFAULT_INSTANCE,extensions:[],dependencies:{}};function Fe(e,t){const r=t.bufferViews[e.bufferView],n=t.jsonDoc.json.bufferViews[e.bufferView],s=Be[e.componentType],i=ue.getElementSize(e.type),o=s.BYTES_PER_ELEMENT;if(void 0!==n.byteStride&&n.byteStride!==i*o)return function(e,t){const r=t.bufferViews[e.bufferView],n=t.jsonDoc.json.bufferViews[e.bufferView],s=Be[e.componentType],i=ue.getElementSize(e.type),o=s.BYTES_PER_ELEMENT,a=e.byteOffset||0,c=new s(e.count*i),u=new DataView(r.buffer,r.byteOffset,r.byteLength),l=n.byteStride;for(let t=0;t<e.count;t++)for(let r=0;r<i;r++){const n=a+t*l+r*o;let s;switch(e.componentType){case ue.ComponentType.FLOAT:s=u.getFloat32(n,!0);break;case ue.ComponentType.UNSIGNED_INT:s=u.getUint32(n,!0);break;case ue.ComponentType.UNSIGNED_SHORT:s=u.getUint16(n,!0);break;case ue.ComponentType.UNSIGNED_BYTE:s=u.getUint8(n);break;case ue.ComponentType.SHORT:s=u.getInt16(n,!0);break;case ue.ComponentType.BYTE:s=u.getInt8(n);break;default:throw new Error(`Unexpected componentType "${e.componentType}".`)}c[t*i+r]=s}return c}(e,t);const a=r.byteOffset+(e.byteOffset||0);return new s(r.buffer.slice(a,a+e.count*i*o))}var Ue;!function(e){e[e.ARRAY_BUFFER=34962]="ARRAY_BUFFER",e[e.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER"}(Ue||(Ue={}));class Oe{constructor(e,t,r){this.N=void 0,this.jsonDoc=void 0,this.options=void 0,this.accessorIndexMap=new Map,this.animationIndexMap=new Map,this.bufferIndexMap=new Map,this.cameraIndexMap=new Map,this.skinIndexMap=new Map,this.materialIndexMap=new Map,this.meshIndexMap=new Map,this.nodeIndexMap=new Map,this.imageIndexMap=new Map,this.textureDefIndexMap=new Map,this.textureInfoDefMap=new Map,this.samplerDefIndexMap=new Map,this.sceneIndexMap=new Map,this.imageBufferViews=[],this.otherBufferViews=new Map,this.otherBufferViewsIndexMap=new Map,this.extensionData={},this.bufferURIGenerator=void 0,this.imageURIGenerator=void 0,this.logger=void 0,this.O=new Map,this.accessorUsageGroupedByParent=new Set(["ARRAY_BUFFER"]),this.accessorParents=new Map,this.N=e,this.jsonDoc=t,this.options=r;const n=e.getRoot(),s=n.listBuffers().length,i=n.listTextures().length;this.bufferURIGenerator=new Pe(s>1,r.basename),this.imageURIGenerator=new Pe(i>1,r.basename),this.logger=e.getLogger()}createTextureInfoDef(e,t){const r={magFilter:t.getMagFilter()||void 0,minFilter:t.getMinFilter()||void 0,wrapS:t.getWrapS(),wrapT:t.getWrapT()},n=JSON.stringify(r);this.samplerDefIndexMap.has(n)||(this.samplerDefIndexMap.set(n,this.jsonDoc.json.samplers.length),this.jsonDoc.json.samplers.push(r));const s={source:this.imageIndexMap.get(e),sampler:this.samplerDefIndexMap.get(n)},i=JSON.stringify(s);this.textureDefIndexMap.has(i)||(this.textureDefIndexMap.set(i,this.jsonDoc.json.textures.length),this.jsonDoc.json.textures.push(s));const o={index:this.textureDefIndexMap.get(i)};return 0!==t.getTexCoord()&&(o.texCoord=t.getTexCoord()),this.textureInfoDefMap.set(t,o),o}createPropertyDef(e){const t={};return e.getName()&&(t.name=e.getName()),Object.keys(e.getExtras()).length>0&&(t.extras=e.getExtras()),t}createAccessorDef(e){const t=this.createPropertyDef(e);return t.type=e.getType(),t.componentType=e.getComponentType(),t.count=e.getCount(),this.N.getGraph().listParentEdges(e).some((e=>"attributes"===e.getName()&&"POSITION"===e.getAttributes().key||"input"===e.getName()))&&(t.max=e.getMax([]).map(Math.fround),t.min=e.getMin([]).map(Math.fround)),e.getNormalized()&&(t.normalized=e.getNormalized()),t}createImageData(e,t,r){if(this.options.format===L.GLB)this.imageBufferViews.push(t),e.bufferView=this.jsonDoc.json.bufferViews.length,this.jsonDoc.json.bufferViews.push({buffer:0,byteOffset:-1,byteLength:t.byteLength});else{const n=G.mimeTypeToExtension(r.getMimeType());e.uri=this.imageURIGenerator.createURI(r,n),this.jsonDoc.resources[e.uri]=t}}getAccessorUsage(e){const t=this.O.get(e);if(t)return t;for(const t of this.N.getGraph().listParentEdges(e)){const{usage:e}=t.getAttributes();if(e)return e;t.getParent().propertyType!==F.ROOT&&this.N.getLogger().warn(`Missing attribute ".usage" on edge, "${t.getName()}".`)}return Oe.BufferViewUsage.OTHER}addAccessorToUsageGroup(e,t){const r=this.O.get(e);if(r&&r!==t)throw new Error(`Accessor with usage "${r}" cannot be reused as "${t}".`);return this.O.set(e,t),this}listAccessorUsageGroups(){const e={};for(const[t,r]of Array.from(this.O.entries()))e[r]=e[r]||[],e[r].push(t);return e}}Oe.BufferViewTarget=Ue,Oe.BufferViewUsage=O,Oe.USAGE_TO_TARGET={[O.ARRAY_BUFFER]:Ue.ARRAY_BUFFER,[O.ELEMENT_ARRAY_BUFFER]:Ue.ELEMENT_ARRAY_BUFFER};class Pe{constructor(e,t){this.multiple=void 0,this.basename=void 0,this.counter=1,this.multiple=e,this.basename=t}createURI(e,t){return e.getURI()?e.getURI():this.multiple?`${this.basename}_${this.counter++}.${t}`:`${this.basename}.${t}`}}const{BufferViewUsage:Le}=Oe;var De;!function(e){e[e.JSON=1313821514]="JSON",e[e.BIN=5130562]="BIN"}(De||(De={}));class Ve extends class{constructor(){this.v=W.DEFAULT_INSTANCE,this.h=new Set,this.C={},this.F=U.INTERLEAVED,this.lastReadBytes=0,this.lastWriteBytes=0}setLogger(e){return this.v=e,this}registerExtensions(e){for(const t of e)this.h.add(t),t.register();return this}registerDependencies(e){return Object.assign(this.C,e),this}setVertexLayout(e){return this.F=e,this}async read(e){return await this.readJSON(await this.readAsJSON(e))}async readAsJSON(e){return e.match(/^data:application\/octet-stream;/)||this.detectFormat(e)===L.GLB?this.U(e):this.P(e)}async readJSON(e){return e=this.j(e),this.L(e),class{static read(e,t=_e){const r=Ae({},_e,t),{json:n}=e,s=new Ne;this.validate(e,r);const i=new ze(e),o=n.asset,a=s.getRoot().getAsset();o.copyright&&(a.copyright=o.copyright),o.extras&&(a.extras=o.extras),void 0!==n.extras&&s.getRoot().setExtras(Ae({},n.extras));const c=n.extensionsUsed||[],u=n.extensionsRequired||[];for(const e of r.extensions)if(c.includes(e.EXTENSION_NAME)){const t=s.createExtension(e).setRequired(u.includes(e.EXTENSION_NAME));for(const e of t.readDependencies)t.install(e,r.dependencies[e])}const l=n.buffers||[];s.getRoot().listExtensionsUsed().filter((e=>e.prereadTypes.includes(F.BUFFER))).forEach((e=>e.preread(i,F.BUFFER))),i.buffers=l.map((e=>{const t=s.createBuffer(e.name);return e.extras&&t.setExtras(e.extras),e.uri&&0!==e.uri.indexOf("__")&&t.setURI(e.uri),t})),i.bufferViewBuffers=(n.bufferViews||[]).map(((t,r)=>{if(!i.bufferViews[r]){const n=e.json.buffers[t.buffer];i.bufferViews[r]=D.toView(n.uri?e.resources[n.uri]:e.resources["@glb.bin"],t.byteOffset||0,t.byteLength)}return i.buffers[t.buffer]})),i.accessors=(n.accessors||[]).map((e=>{const t=s.createAccessor(e.name,i.bufferViewBuffers[e.bufferView]).setType(e.type);if(e.extras&&t.setExtras(e.extras),void 0!==e.normalized&&t.setNormalized(e.normalized),void 0===e.bufferView&&!e.sparse)return t;let r;return r=void 0!==e.sparse?function(e,t){const r=Be[e.componentType],n=ue.getElementSize(e.type);let s;s=void 0!==e.bufferView?Fe(e,t):new r(e.count*n);const i=e.sparse,o=i.count,a=Ae({},e,i.indices,{count:o,type:"SCALAR"}),c=Ae({},e,i.values,{count:o}),u=Fe(a,t),l=Fe(c,t);for(let e=0;e<a.count;e++)for(let t=0;t<n;t++)s[u[e]*n+t]=l[e*n+t];return s}(e,i):Fe(e,i),t.setArray(r),t}));const f=n.images||[],h=n.textures||[];s.getRoot().listExtensionsUsed().filter((e=>e.prereadTypes.includes(F.TEXTURE))).forEach((e=>e.preread(i,F.TEXTURE))),i.textures=f.map((t=>{const r=s.createTexture(t.name);if(t.extras&&r.setExtras(t.extras),void 0!==t.bufferView){const s=n.bufferViews[t.bufferView],i=e.json.buffers[s.buffer],o=s.byteOffset||0,a=(i.uri?e.resources[i.uri]:e.resources["@glb.bin"]).slice(o,o+s.byteLength);r.setImage(a)}else void 0!==t.uri&&(r.setImage(e.resources[t.uri]),0!==t.uri.indexOf("__")&&r.setURI(t.uri));if(void 0!==t.mimeType)r.setMimeType(t.mimeType);else if(t.uri){const e=q.extension(t.uri);r.setMimeType(G.extensionToMimeType(e))}return r})),i.materials=(n.materials||[]).map((e=>{const t=s.createMaterial(e.name);e.extras&&t.setExtras(e.extras),void 0!==e.alphaMode&&t.setAlphaMode(e.alphaMode),void 0!==e.alphaCutoff&&t.setAlphaCutoff(e.alphaCutoff),void 0!==e.doubleSided&&t.setDoubleSided(e.doubleSided);const r=e.pbrMetallicRoughness||{};if(void 0!==r.baseColorFactor&&t.setBaseColorFactor(r.baseColorFactor),void 0!==e.emissiveFactor&&t.setEmissiveFactor(e.emissiveFactor),void 0!==r.metallicFactor&&t.setMetallicFactor(r.metallicFactor),void 0!==r.roughnessFactor&&t.setRoughnessFactor(r.roughnessFactor),void 0!==r.baseColorTexture){const e=r.baseColorTexture;t.setBaseColorTexture(i.textures[h[e.index].source]),i.setTextureInfo(t.getBaseColorTextureInfo(),e)}if(void 0!==e.emissiveTexture){const r=e.emissiveTexture;t.setEmissiveTexture(i.textures[h[r.index].source]),i.setTextureInfo(t.getEmissiveTextureInfo(),r)}if(void 0!==e.normalTexture){const r=e.normalTexture;t.setNormalTexture(i.textures[h[r.index].source]),i.setTextureInfo(t.getNormalTextureInfo(),r),void 0!==e.normalTexture.scale&&t.setNormalScale(e.normalTexture.scale)}if(void 0!==e.occlusionTexture){const r=e.occlusionTexture;t.setOcclusionTexture(i.textures[h[r.index].source]),i.setTextureInfo(t.getOcclusionTextureInfo(),r),void 0!==e.occlusionTexture.strength&&t.setOcclusionStrength(e.occlusionTexture.strength)}if(void 0!==r.metallicRoughnessTexture){const e=r.metallicRoughnessTexture;t.setMetallicRoughnessTexture(i.textures[h[e.index].source]),i.setTextureInfo(t.getMetallicRoughnessTextureInfo(),e)}return t}));const p=n.meshes||[];s.getRoot().listExtensionsUsed().filter((e=>e.prereadTypes.includes(F.PRIMITIVE))).forEach((e=>e.preread(i,F.PRIMITIVE))),i.meshes=p.map((e=>{const t=s.createMesh(e.name);return e.extras&&t.setExtras(e.extras),void 0!==e.weights&&t.setWeights(e.weights),(e.primitives||[]).forEach((r=>{const n=s.createPrimitive();r.extras&&n.setExtras(r.extras),void 0!==r.material&&n.setMaterial(i.materials[r.material]),void 0!==r.mode&&n.setMode(r.mode);for(const[e,t]of Object.entries(r.attributes||{}))n.setAttribute(e,i.accessors[t]);void 0!==r.indices&&n.setIndices(i.accessors[r.indices]);const o=e.extras&&e.extras.targetNames||[];(r.targets||[]).forEach(((e,t)=>{const r=o[t]||t.toString(),a=s.createPrimitiveTarget(r);for(const[t,r]of Object.entries(e))a.setAttribute(t,i.accessors[r]);n.addTarget(a)})),t.addPrimitive(n)})),t})),i.cameras=(n.cameras||[]).map((e=>{const t=s.createCamera(e.name).setType(e.type);if(e.extras&&t.setExtras(e.extras),e.type===ge.Type.PERSPECTIVE){const r=e.perspective;t.setYFov(r.yfov),t.setZNear(r.znear),void 0!==r.zfar&&t.setZFar(r.zfar),void 0!==r.aspectRatio&&t.setAspectRatio(r.aspectRatio)}else{const r=e.orthographic;t.setZNear(r.znear).setZFar(r.zfar).setXMag(r.xmag).setYMag(r.ymag)}return t}));const g=n.nodes||[];s.getRoot().listExtensionsUsed().filter((e=>e.prereadTypes.includes(F.NODE))).forEach((e=>e.preread(i,F.NODE))),i.nodes=g.map((e=>{const t=s.createNode(e.name);if(e.extras&&t.setExtras(e.extras),void 0!==e.translation&&t.setTranslation(e.translation),void 0!==e.rotation&&t.setRotation(e.rotation),void 0!==e.scale&&t.setScale(e.scale),void 0!==e.matrix){const r=[0,0,0],n=[0,0,0,1],s=[1,1,1];H.decompose(e.matrix,r,n,s),t.setTranslation(r),t.setRotation(n),t.setScale(s)}return void 0!==e.weights&&t.setWeights(e.weights),t})),i.skins=(n.skins||[]).map((e=>{const t=s.createSkin(e.name);e.extras&&t.setExtras(e.extras),void 0!==e.inverseBindMatrices&&t.setInverseBindMatrices(i.accessors[e.inverseBindMatrices]),void 0!==e.skeleton&&t.setSkeleton(i.nodes[e.skeleton]);for(const r of e.joints)t.addJoint(i.nodes[r]);return t})),g.map(((e,t)=>{const r=i.nodes[t];(e.children||[]).forEach((e=>r.addChild(i.nodes[e]))),void 0!==e.mesh&&r.setMesh(i.meshes[e.mesh]),void 0!==e.camera&&r.setCamera(i.cameras[e.camera]),void 0!==e.skin&&r.setSkin(i.skins[e.skin])})),i.animations=(n.animations||[]).map((e=>{const t=s.createAnimation(e.name);e.extras&&t.setExtras(e.extras);const r=(e.samplers||[]).map((e=>{const r=s.createAnimationSampler().setInput(i.accessors[e.input]).setOutput(i.accessors[e.output]).setInterpolation(e.interpolation||he.Interpolation.LINEAR);return e.extras&&r.setExtras(e.extras),t.addSampler(r),r}));return(e.channels||[]).forEach((e=>{const n=s.createAnimationChannel().setSampler(r[e.sampler]).setTargetPath(e.target.path);void 0!==e.target.node&&n.setTargetNode(i.nodes[e.target.node]),e.extras&&n.setExtras(e.extras),t.addChannel(n)})),t}));const d=n.scenes||[];return s.getRoot().listExtensionsUsed().filter((e=>e.prereadTypes.includes(F.SCENE))).forEach((e=>e.preread(i,F.SCENE))),i.scenes=d.map((e=>{const t=s.createScene(e.name);return e.extras&&t.setExtras(e.extras),(e.nodes||[]).map((e=>i.nodes[e])).forEach((e=>t.addChild(e))),t})),void 0!==n.scene&&s.getRoot().setDefaultScene(i.scenes[n.scene]),s.getRoot().listExtensionsUsed().forEach((e=>e.read(i))),s}static validate(e,t){const r=e.json;if("2.0"!==r.asset.version)throw new Error(`Unsupported glTF version, "${r.asset.version}".`);if(r.extensionsRequired)for(const e of r.extensionsRequired)if(!t.extensions.find((t=>t.EXTENSION_NAME===e)))throw new Error(`Missing required extension, "${e}".`);if(r.extensionsUsed)for(const e of r.extensionsUsed)t.extensions.find((t=>t.EXTENSION_NAME===e))||t.logger.warn(`Missing optional extension, "${e}".`)}}.read(e,{extensions:Array.from(this.h),dependencies:this.C,logger:this.v})}async binaryToJSON(e){const t=this._(D.assertView(e));this.L(t);const r=t.json;if(r.buffers&&r.buffers.some((e=>function(e,t){return void 0!==t.uri&&!(t.uri in e.resources)}(t,e))))throw new Error("Cannot resolve external buffers with binaryToJSON().");if(r.images&&r.images.some((e=>function(e,t){return void 0!==t.uri&&!(t.uri in e.resources)&&void 0===t.bufferView}(t,e))))throw new Error("Cannot resolve external images with binaryToJSON().");return t}async readBinary(e){return this.readJSON(await this.binaryToJSON(D.assertView(e)))}async writeJSON(e,t={}){if(t.format===L.GLB&&e.getRoot().listBuffers().length>1)throw new Error("GLB must have 0–1 buffers.");return class{static write(e,t){const r=e.getRoot(),n={asset:Ae({generator:"glTF-Transform v2.2.2"},r.getAsset()),extras:Ae({},r.getExtras())},s={json:n,resources:{}},i=new Oe(e,s,t),o=t.logger||W.DEFAULT_INSTANCE,a=new Set(t.extensions.map((e=>e.EXTENSION_NAME))),c=e.getRoot().listExtensionsUsed().filter((e=>a.has(e.extensionName))),u=e.getRoot().listExtensionsRequired().filter((e=>a.has(e.extensionName)));c.length<e.getRoot().listExtensionsUsed().length&&o.debug("Some extensions were not registered for I/O, and will not be written.");for(const e of c)for(const r of e.writeDependencies)e.install(r,t.dependencies[r]);function l(e,t,r,s){const o=[];let a=0;for(const t of e){const e=i.createAccessorDef(t);e.bufferView=n.bufferViews.length;const r=t.getArray(),s=D.pad(D.toView(r));e.byteOffset=a,a+=s.byteLength,o.push(s),i.accessorIndexMap.set(t,n.accessors.length),n.accessors.push(e)}const c={buffer:t,byteOffset:r,byteLength:D.concat(o).byteLength};return s&&(c.target=s),n.bufferViews.push(c),{buffers:o,byteLength:a}}function f(e,t,r){const s=e[0].getCount();let o=0;for(const t of e){const e=i.createAccessorDef(t);e.bufferView=n.bufferViews.length,e.byteOffset=o;const r=t.getElementSize(),s=t.getComponentSize();o+=D.padNumber(r*s),i.accessorIndexMap.set(t,n.accessors.length),n.accessors.push(e)}const a=s*o,c=new ArrayBuffer(a),u=new DataView(c);for(let t=0;t<s;t++){let r=0;for(const n of e){const e=n.getElementSize(),s=n.getComponentSize(),i=n.getComponentType(),a=n.getArray();for(let n=0;n<e;n++){const c=t*o+r+n*s,l=a[t*e+n];switch(i){case ue.ComponentType.FLOAT:u.setFloat32(c,l,!0);break;case ue.ComponentType.BYTE:u.setInt8(c,l);break;case ue.ComponentType.SHORT:u.setInt16(c,l,!0);break;case ue.ComponentType.UNSIGNED_BYTE:u.setUint8(c,l);break;case ue.ComponentType.UNSIGNED_SHORT:u.setUint16(c,l,!0);break;case ue.ComponentType.UNSIGNED_INT:u.setUint32(c,l,!0);break;default:throw new Error("Unexpected component type: "+i)}}r+=D.padNumber(e*s)}}return n.bufferViews.push({buffer:t,byteOffset:r,byteLength:a,byteStride:o,target:Oe.BufferViewTarget.ARRAY_BUFFER}),{byteLength:a,buffers:[new Uint8Array(c)]}}const h=new Map;for(const t of e.getGraph().listEdges()){if(t.getParent()===r)continue;const e=t.getChild();if(e instanceof ue){const r=h.get(e)||[];r.push(t),h.set(e,r)}}if(n.accessors=[],n.bufferViews=[],n.samplers=[],n.textures=[],n.images=r.listTextures().map(((e,t)=>{const r=i.createPropertyDef(e);e.getMimeType()&&(r.mimeType=e.getMimeType());const n=e.getImage();return n&&i.createImageData(r,n,e),i.imageIndexMap.set(e,t),r})),c.filter((e=>e.prewriteTypes.includes(F.ACCESSOR))).forEach((e=>e.prewrite(i,F.ACCESSOR))),r.listAccessors().forEach((e=>{const t=i.accessorUsageGroupedByParent,r=i.accessorParents;if(i.accessorIndexMap.has(e))return;const n=h.get(e)||[],s=i.getAccessorUsage(e);if(i.addAccessorToUsageGroup(e,s),t.has(s)){const t=n[0].getParent(),s=r.get(t)||new Set;s.add(e),r.set(t,s)}})),c.filter((e=>e.prewriteTypes.includes(F.BUFFER))).forEach((e=>e.prewrite(i,F.BUFFER))),(r.listAccessors().length>0||r.listTextures().length>0||i.otherBufferViews.size>0)&&0===r.listBuffers().length)throw new Error("Buffer required for Document resources, but none was found.");n.buffers=[],r.listBuffers().forEach(((e,r)=>{const o=i.createPropertyDef(e),a=i.accessorUsageGroupedByParent,c=i.accessorParents,u=e.listParents().filter((e=>e instanceof ue)),h=new Set(u),p=[],g=n.buffers.length;let d=0;const m=i.listAccessorUsageGroups();for(const e in m)if(a.has(e))for(const r of Array.from(c.values())){const n=Array.from(r).filter((e=>h.has(e))).filter((t=>i.getAccessorUsage(t)===e));if(n.length)if(e!==Le.ARRAY_BUFFER||t.vertexLayout===U.INTERLEAVED){const t=e===Le.ARRAY_BUFFER?f(n,g,d):l(n,g,d);d+=t.byteLength,p.push(...t.buffers)}else for(const e of n){const t=f([e],g,d);d+=t.byteLength,p.push(...t.buffers)}}else{const t=m[e].filter((e=>h.has(e)));if(!t.length)continue;const r=l(t,g,d,e===Le.ELEMENT_ARRAY_BUFFER?Oe.BufferViewTarget.ELEMENT_ARRAY_BUFFER:void 0);d+=r.byteLength,p.push(...r.buffers)}if(i.imageBufferViews.length&&0===r)for(let e=0;e<i.imageBufferViews.length;e++)if(n.bufferViews[n.images[e].bufferView].byteOffset=d,d+=i.imageBufferViews[e].byteLength,p.push(i.imageBufferViews[e]),d%8){const e=8-d%8;d+=e,p.push(new Uint8Array(e))}if(i.otherBufferViews.has(e))for(const t of i.otherBufferViews.get(e))n.bufferViews.push({buffer:g,byteOffset:d,byteLength:t.byteLength}),i.otherBufferViewsIndexMap.set(t,n.bufferViews.length-1),d+=t.byteLength,p.push(t);if(d){let r;t.format===L.GLB?r="@glb.bin":(r=i.bufferURIGenerator.createURI(e,"bin"),o.uri=r),o.byteLength=d,s.resources[r]=D.concat(p)}n.buffers.push(o),i.bufferIndexMap.set(e,r)})),r.listAccessors().find((e=>!e.getBuffer()))&&o.warn("Skipped writing one or more Accessors: no Buffer assigned."),n.materials=r.listMaterials().map(((e,t)=>{const r=i.createPropertyDef(e);if(e.getAlphaMode()!==Te.AlphaMode.OPAQUE&&(r.alphaMode=e.getAlphaMode()),e.getAlphaMode()===Te.AlphaMode.MASK&&(r.alphaCutoff=e.getAlphaCutoff()),e.getDoubleSided()&&(r.doubleSided=!0),r.pbrMetallicRoughness={},H.eq(e.getBaseColorFactor(),[1,1,1,1])||(r.pbrMetallicRoughness.baseColorFactor=e.getBaseColorFactor()),H.eq(e.getEmissiveFactor(),[0,0,0])||(r.emissiveFactor=e.getEmissiveFactor()),1!==e.getRoughnessFactor()&&(r.pbrMetallicRoughness.roughnessFactor=e.getRoughnessFactor()),1!==e.getMetallicFactor()&&(r.pbrMetallicRoughness.metallicFactor=e.getMetallicFactor()),e.getBaseColorTexture()){const t=e.getBaseColorTexture(),n=e.getBaseColorTextureInfo();r.pbrMetallicRoughness.baseColorTexture=i.createTextureInfoDef(t,n)}if(e.getEmissiveTexture()){const t=e.getEmissiveTexture(),n=e.getEmissiveTextureInfo();r.emissiveTexture=i.createTextureInfoDef(t,n)}if(e.getNormalTexture()){const t=e.getNormalTexture(),n=e.getNormalTextureInfo(),s=i.createTextureInfoDef(t,n);1!==e.getNormalScale()&&(s.scale=e.getNormalScale()),r.normalTexture=s}if(e.getOcclusionTexture()){const t=e.getOcclusionTexture(),n=e.getOcclusionTextureInfo(),s=i.createTextureInfoDef(t,n);1!==e.getOcclusionStrength()&&(s.strength=e.getOcclusionStrength()),r.occlusionTexture=s}if(e.getMetallicRoughnessTexture()){const t=e.getMetallicRoughnessTexture(),n=e.getMetallicRoughnessTextureInfo();r.pbrMetallicRoughness.metallicRoughnessTexture=i.createTextureInfoDef(t,n)}return i.materialIndexMap.set(e,t),r})),n.meshes=r.listMeshes().map(((e,t)=>{const r=i.createPropertyDef(e);let n=null;return r.primitives=e.listPrimitives().map((e=>{const t={attributes:{}};t.mode=e.getMode();const r=e.getMaterial();r&&(t.material=i.materialIndexMap.get(r)),Object.keys(e.getExtras()).length&&(t.extras=e.getExtras());const s=e.getIndices();s&&(t.indices=i.accessorIndexMap.get(s));for(const r of e.listSemantics())t.attributes[r]=i.accessorIndexMap.get(e.getAttribute(r));for(const r of e.listTargets()){const e={};for(const t of r.listSemantics())e[t]=i.accessorIndexMap.get(r.getAttribute(t));t.targets=t.targets||[],t.targets.push(e)}return e.listTargets().length&&!n&&(n=e.listTargets().map((e=>e.getName()))),t})),e.getWeights().length&&(r.weights=e.getWeights()),n&&(r.extras=r.extras||{},r.extras.targetNames=n),i.meshIndexMap.set(e,t),r})),n.cameras=r.listCameras().map(((e,t)=>{const r=i.createPropertyDef(e);if(r.type=e.getType(),r.type===ge.Type.PERSPECTIVE){r.perspective={znear:e.getZNear(),zfar:e.getZFar(),yfov:e.getYFov()};const t=e.getAspectRatio();null!==t&&(r.perspective.aspectRatio=t)}else r.orthographic={znear:e.getZNear(),zfar:e.getZFar(),xmag:e.getXMag(),ymag:e.getYMag()};return i.cameraIndexMap.set(e,t),r})),n.nodes=r.listNodes().map(((e,t)=>{const r=i.createPropertyDef(e);return H.eq(e.getTranslation(),[0,0,0])||(r.translation=e.getTranslation()),H.eq(e.getRotation(),[0,0,0,1])||(r.rotation=e.getRotation()),H.eq(e.getScale(),[1,1,1])||(r.scale=e.getScale()),e.getWeights().length&&(r.weights=e.getWeights()),i.nodeIndexMap.set(e,t),r})),n.skins=r.listSkins().map(((e,t)=>{const r=i.createPropertyDef(e),n=e.getInverseBindMatrices();n&&(r.inverseBindMatrices=i.accessorIndexMap.get(n));const s=e.getSkeleton();return s&&(r.skeleton=i.nodeIndexMap.get(s)),r.joints=e.listJoints().map((e=>i.nodeIndexMap.get(e))),i.skinIndexMap.set(e,t),r})),r.listNodes().forEach(((e,t)=>{const r=n.nodes[t],s=e.getMesh();s&&(r.mesh=i.meshIndexMap.get(s));const o=e.getCamera();o&&(r.camera=i.cameraIndexMap.get(o));const a=e.getSkin();a&&(r.skin=i.skinIndexMap.get(a)),e.listChildren().length>0&&(r.children=e.listChildren().map((e=>i.nodeIndexMap.get(e))))})),n.animations=r.listAnimations().map(((e,t)=>{const r=i.createPropertyDef(e),n=new Map;return r.samplers=e.listSamplers().map(((e,t)=>{const r=i.createPropertyDef(e);return r.input=i.accessorIndexMap.get(e.getInput()),r.output=i.accessorIndexMap.get(e.getOutput()),r.interpolation=e.getInterpolation(),n.set(e,t),r})),r.channels=e.listChannels().map((e=>{const t=i.createPropertyDef(e);return t.sampler=n.get(e.getSampler()),t.target={node:i.nodeIndexMap.get(e.getTargetNode()),path:e.getTargetPath()},t})),i.animationIndexMap.set(e,t),r})),n.scenes=r.listScenes().map(((e,t)=>{const r=i.createPropertyDef(e);return r.nodes=e.listChildren().map((e=>i.nodeIndexMap.get(e))),i.sceneIndexMap.set(e,t),r}));const p=r.getDefaultScene();return p&&(n.scene=r.listScenes().indexOf(p)),n.extensionsUsed=c.map((e=>e.extensionName)),n.extensionsRequired=u.map((e=>e.extensionName)),c.forEach((e=>e.write(i))),function(e){const t=[];for(const r in e){const n=e[r];(Array.isArray(n)&&0===n.length||null===n||""===n||n&&"object"==typeof n&&0===Object.keys(n).length)&&t.push(r)}for(const r of t)delete e[r]}(n),s}}.write(e,{format:t.format||L.GLTF,basename:t.basename||"",logger:this.v,vertexLayout:this.F,dependencies:Ae({},this.C),extensions:Array.from(this.h)})}async writeBinary(e){const{json:t,resources:r}=await this.writeJSON(e,{format:L.GLB}),n=new Uint32Array([1179937895,2,12]),s=JSON.stringify(t),i=D.pad(D.encodeText(s),32),o=D.toView(new Uint32Array([i.byteLength,1313821514])),a=D.concat([o,i]);n[n.length-1]+=a.byteLength;const c=Object.values(r)[0];if(!c||!c.byteLength)return D.concat([D.toView(n),a]);const u=D.pad(c,0),l=D.toView(new Uint32Array([u.byteLength,5130562])),f=D.concat([l,u]);return n[n.length-1]+=f.byteLength,D.concat([D.toView(n),a,f])}detectFormat(e){return"glb"===(se.isAbsoluteURL(e)?se.extension(e):q.extension(e))?L.GLB:L.GLTF}async P(e){this.lastReadBytes=0;const t=await this.readURI(e,"text");this.lastReadBytes+=t.length;const r={json:JSON.parse(t),resources:{}};return await this.D(r,this.dirname(e)),this.L(r),r}async U(e){const t=await this.readURI(e,"view");this.lastReadBytes=t.byteLength;const r=this._(t);return await this.D(r,this.dirname(e)),this.L(r),r}async D(e,t){var r=this;const n=[...e.json.images||[],...e.json.buffers||[]].map((async function(n){const s=n.uri;if(!s||s.match(/data:/))return Promise.resolve();e.resources[s]=await r.readURI(r.resolve(t,s),"view"),r.lastReadBytes+=e.resources[s].byteLength}));await Promise.all(n)}L(e){function t(t){if(t.uri)if(t.uri in e.resources)D.assertView(e.resources[t.uri]);else if(t.uri.match(/data:/)){const r=`__${function(){for(let e=0;e<999;e++){const e=ne();if(!re.has(e))return re.add(e),e}return""}()}.${q.extension(t.uri)}`;e.resources[r]=D.createBufferFromDataURI(t.uri),t.uri=r}}(e.json.images||[]).forEach((e=>{if(void 0===e.bufferView&&void 0===e.uri)throw new Error("Missing resource URI or buffer view.");t(e)})),(e.json.buffers||[]).forEach(t)}j(e){const{images:t,buffers:r}=e.json;return e={json:Ae({},e.json),resources:Ae({},e.resources)},t&&(e.json.images=t.map((e=>Ae({},e)))),r&&(e.json.buffers=r.map((e=>Ae({},e)))),e}_(e){const t=new Uint32Array(e.buffer,e.byteOffset,3);if(1179937895!==t[0])throw new Error("Invalid glTF asset.");if(2!==t[1])throw new Error(`Unsupported glTF binary version, "${t[1]}".`);const r=new Uint32Array(e.buffer,e.byteOffset+12,2);if(r[1]!==De.JSON)throw new Error("Missing required GLB JSON chunk.");const n=r[0],s=D.decodeText(D.toView(e,20,n)),i=JSON.parse(s),o=20+n;if(e.byteLength<=o)return{json:i,resources:{}};const a=new Uint32Array(e.buffer,e.byteOffset+o,2);if(a[1]!==De.BIN)throw new Error("Expected GLB BIN in second chunk.");return{json:i,resources:{"@glb.bin":D.toView(e,o+8,a[0])}}}}{constructor(e=se.DEFAULT_INIT){super(),this.V=void 0,this.V=e}async readURI(e,t){const r=await fetch(e,this.V);switch(t){case"view":return new Uint8Array(await r.arrayBuffer());case"text":return r.text()}}resolve(e,t){return se.resolve(e,t)}dirname(e){return se.dirname(e)}detectFormat(e){return"glb"===se.extension(e)?L.GLB:L.GLTF}}const ke=l(0,0,0),Ge=(e,t,r,n)=>{const s=.25*t,i=.75*n.width;!function(e,t,r){e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2]}(r.camera.position,r.camera.target,f(ke,Math.sin(s)*i,0,Math.cos(s)*i)),r.camera.updateView()},je={onAnimation:Ge,onLoad:e=>e.setClearColor(.7,.6,.2),source:"\n  fn distanceToScene(pos : vec3<f32>) -> f32 {\n    var origin : vec3<f32> = pos - volume.center;\n    var t : f32 = sin(time * 2);\n    var size : f32 = volume.size.x * (0.25 + t * 0.01);\n    return opSmoothUnion(\n      sdSphere(origin - vec3<f32>(size * (0.6 * t * -1), size * 0.2 * t * -1, 0), size),\n      sdSphere(origin - vec3<f32>(size * (0.6 * t), size * 0.2 * t, 0), size),\n      100\n    );\n  }\n  fn getValueAt(pos : vec3<f32>) -> f32 {\n    if (distanceToScene(pos) > 0.01) {\n      return 0;\n    }\n    return 1 + abs(simplexNoise3(pos * 0.01)) * 254;\n  }\n  "},qe={onAnimation:Ge,onLoad:e=>e.setClearColor(.1,.3,.6),source:"\n  fn distanceToScene(pos : vec3<f32>) -> f32 {\n    var origin : vec3<f32> = pos - volume.center;\n    var r : mat3x3<f32> = rotateX(PI * -0.5);\n    return opUnion(\n      sdTorus(\n        r * origin,\n        vec2<f32>(volume.size.x * 0.3, volume.size.x * 0.1)\n      ),\n      sdTorus(\n        r * rotateY(time) * origin,\n        vec2<f32>(volume.size.x * 0.1, volume.size.x * (0.02 + sin(time * 10) * 0.01))\n      )\n    );\n  }\n  fn getValueAt(pos : vec3<f32>) -> f32 {\n    if (distanceToScene(pos) > 0.01) {\n      return 0;\n    }\n    return 1 + abs(simplexNoise3(pos * 0.01)) * 254;\n  }\n  "},Ye={onAnimation:Ge,onLoad:e=>e.setClearColor(.1,.2,.4),source:"\n  fn getValueAt(pos : vec3<f32>) -> f32 {\n    var p : vec3<f32> = pos + vec3<f32>(0, 0, round(time * 100));\n    var h : f32 = abs(simplexNoise3(p * 0.01)) * volume.size.y;\n    if (pos.y > h) {\n      return 0;\n    }\n    return 1 + abs(simplexNoise3(p * -0.001)) * 254;\n  }\n  "},$e={onAnimation:Ge,onLoad:e=>e.setClearColor(.1,.1,.1),source:"\n  fn distanceToScene(pos : vec3<f32>) -> f32 {\n    if (sdSphere(pos - volume.center, volume.size.x * 0.35) > 0.01) {\n      return 1;\n    }\n    var id : f32 = noise3(floor(pos / 32));\n    var p : vec3<f32> = (pos % 32) - 16;\n    var t : f32 = sin((time + id) * 4);\n    var d : f32;\n    if (floor(id * 10) % 2 == 0) {\n      d = sdSphere(p, t * 4 + 8);\n    } else {\n      d = sdBox(p, vec3<f32>(t * 4 + 8));\n    }\n    return opSmoothSubstraction(\n      opSmoothSubstraction(\n        d,\n        sdBox(p, vec3<f32>(4, 4, 12)),\n        1\n      ),\n      sdBox(p, vec3<f32>(12, 4, 4)),\n      1\n    );\n  }\n  fn getValueAt(pos : vec3<f32>) -> f32 {\n    if (distanceToScene(pos) > 0.01) {\n      return 0;\n    }\n    return 1 + abs(simplexNoise3(floor(pos / 32))) * 254;\n  }\n  "};var We=e=>{const t=((e,t,r)=>(r.loading=!0,r.maxFPS=0,(new Ve).read(`/models/${e}.glb`).then((e=>{const n=e.getRoot().listMeshes()[0].listPrimitives()[0],s=n.listAttributes()[0],i=new Uint32Array(n.getIndices().getArray()),o=new Float32Array(s.getArray()),a=s.getMin(c()),u=s.getMax(c()),f=h(c(),u,a),p=Math.min(t.width,t.height,t.depth)/Math.max(f[0],f[1],f[2]);r.geometry={indices:i,vertices:o,position:l(.5*t.width,.5*t.height,.5*t.depth),scale:l(p,p,p),source:`\n        fn getValueAt(pos : vec3<f32>) -> f32 {\n          return 1 + (pos.y / ${t.height}) * 254;\n        }\n        `},delete r.loading})),r))("suzanne",e,{onAnimation:Ge,onLoad:e=>e.setClearColor(.1,.1,.1)});return[je,qe,t,Ye,$e]},He=({chunkSize:e})=>`\nconst chunkSize : i32 = ${e};\n\nfn getVoxel(pos : vec3<i32>) -> u32 {\n  return u32(pos.z * chunkSize * chunkSize + pos.y * chunkSize + pos.x);\n}\n`;const Je=({chunkSize:e})=>`\nstruct Faces {\n  vertexCount : u32,\n  instanceCount : atomic<u32>,\n  firstVertex : u32,\n  firstInstance : u32,\n  data : array<f32>,\n}\n\n@group(0) @binding(0) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(1) var<storage, read_write> faces : Faces;\n@group(0) @binding(2) var<storage, read> voxels : array<f32>;\n@group(0) @binding(3) var<storage, read> voxels_north : array<f32>;\n@group(0) @binding(4) var<storage, read> voxels_top : array<f32>;\n@group(0) @binding(5) var<storage, read> voxels_bottom : array<f32>;\n@group(0) @binding(6) var<storage, read> voxels_west : array<f32>;\n@group(0) @binding(7) var<storage, read> voxels_east : array<f32>;\n@group(0) @binding(8) var<storage, read> voxels_south : array<f32>;\n\n${He({chunkSize:e})}\n\nfn isAir(pos : vec3<i32>) -> bool {\n  if (pos.x == -1) {\n    return voxels_west[getVoxel(vec3<i32>(chunkSize - 1, pos.y, pos.z))] == 0;\n  }\n  if (pos.x == chunkSize) {\n    return voxels_east[getVoxel(vec3<i32>(0, pos.y, pos.z))] == 0.0;\n  }\n  if (pos.y == -1) {\n    return voxels_bottom[getVoxel(vec3<i32>(pos.x, chunkSize - 1, pos.z))] == 0;\n  }\n  if (pos.y == chunkSize) {\n    return voxels_top[getVoxel(vec3<i32>(pos.x, 0, pos.z))] == 0;\n  }\n  if (pos.z == -1) {\n    return voxels_south[getVoxel(vec3<i32>(pos.x, pos.y, chunkSize - 1))] == 0;\n  }\n  if (pos.z == chunkSize) {\n    return voxels_north[getVoxel(vec3<i32>(pos.x, pos.y, 0))] == 0;\n  }\n  return voxels[getVoxel(pos)] == 0; \n}\n\nfn pushFace(pos : vec3<i32>, face : i32, texture : i32) {\n  var offset : u32 = atomicAdd(&(faces.instanceCount), 1) * 4;\n  faces.data[offset] = f32(pos.x) + 0.5;\n  faces.data[offset + 1] = f32(pos.y) + 0.5;\n  faces.data[offset + 2] = f32(pos.z) + 0.5;\n  faces.data[offset + 3] = f32(texture * 6 + face);\n}\n\nconst faceNormals = array<vec3<i32>, 6>(\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 1, 0),\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(0, 0, -1),\n);\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize || pos.y >= chunkSize || pos.z >= chunkSize\n  ) {\n    return;\n  }\n  var value : f32 = voxels[getVoxel(pos)];\n  if (value != 0) {\n    var texture : i32 = i32(floor(value) - 1);\n    for (var face : i32 = 0; face < 6; face++) {\n      var npos : vec3<i32> = pos + faceNormals[face];\n      if (isAir(npos)) {\n        pushFace(chunk + pos, face, texture);\n      }\n    }\n  }\n}\n`;class Xe{constructor({chunks:e,volume:t}){this.pipeline=t.device.createComputePipeline({layout:"auto",compute:{module:t.device.createShaderModule({code:Je({chunkSize:t.chunkSize})}),entryPoint:"main"}});const r={x:0,y:0,z:0},n=(n,s)=>{if(r.x=n.x+s.x,r.y=n.y+s.y,r.z=n.z+s.z,r.x<0||r.x>=e.x||r.y<0||r.y>=e.y||r.z<0||r.z>=e.z)return t.edge;const i=r.z*e.x*e.y+r.y*e.x+r.x;return t.chunks[i].voxels},s=[{x:0,y:0,z:1},{x:0,y:1,z:0},{x:0,y:-1,z:0},{x:-1,y:0,z:0},{x:1,y:0,z:0},{x:0,y:0,z:-1}];this.bindings=t.chunks.map((e=>({bindings:t.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[e.position,e.faces,e.voxels,...s.map((t=>n(e.chunk,t)))].map(((e,t)=>({binding:t,resource:{buffer:e}})))}),chunk:e}))),this.workgroups=Math.ceil(t.chunkSize/4)}compute(e){const{bindings:t,pipeline:r,workgroups:n}=this;t.forEach((({bindings:t,chunk:s})=>{s.resetInstanceCount(e);const i=e.beginComputePass();i.setPipeline(r),i.setBindGroup(0,t),i.dispatchWorkgroups(n,n,n),i.end()}))}}const Ze=({chunkSize:e,source:t,triangles:r})=>`\n@group(0) @binding(0) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(1) var<uniform> transform : mat4x4<f32>;\n@group(0) @binding(2) var<storage, read> indices : array<array<u32, 3>>;\n@group(0) @binding(3) var<storage, read> vertices : array<array<f32, 3>>;\n@group(0) @binding(4) var<storage, read_write> voxels : array<f32>;\n\n${He({chunkSize:e})}\n\nstruct AxisTest {\n  ann : vec3<f32>,\n  fnn : vec3<f32>,\n  aa : i32,\n  bb : i32,\n}\n\nfn intersects(triangle : array<vec3<f32>, 3>, voxel : vec3<f32>) -> bool {\n  var v0 : vec3<f32> = triangle[0] - voxel;\n  var v1 : vec3<f32> = triangle[1] - voxel;\n  var v2 : vec3<f32> = triangle[2] - voxel;\n\n  var f0 : vec3<f32> = v1 - v0;\n  var f1 : vec3<f32> = v2 - v1;\n  var f2 : vec3<f32> = v0 - v2;\n\n  var axis_test = array<AxisTest, 9>(\n    AxisTest(vec3<f32>(0, -f0.z, f0.y), f0, 1, 2),\n    AxisTest(vec3<f32>(0, -f1.z, f1.y), f1, 1, 2),\n    AxisTest(vec3<f32>(0, -f2.z, f2.y), f2, 1, 2),\n    AxisTest(vec3<f32>(f0.z, 0, -f0.x), f0, 0, 2),\n    AxisTest(vec3<f32>(f1.z, 0, -f1.x), f1, 0, 2),\n    AxisTest(vec3<f32>(f2.z, 0, -f2.x), f2, 0, 2),\n    AxisTest(vec3<f32>(-f0.y, f0.x, 0), f0, 0, 1),\n    AxisTest(vec3<f32>(-f1.y, f1.x, 0), f1, 0, 1),\n    AxisTest(vec3<f32>(-f2.y, f2.x, 0), f2, 0, 1),\n  );\n\n  for (var i : i32 = 0; i < 9; i++) {\n    var t : AxisTest = axis_test[i];\n    var p0 : f32 = dot(v0, t.ann);\n    var p1 : f32 = dot(v1, t.ann);\n    var p2 : f32 = dot(v2, t.ann);\n    var r : f32 = 0.5 * abs(t.fnn[t.bb]) + 0.5 * abs(t.fnn[t.aa]);\n    if (max(-max(p0, max(p1, p2)), min(p0, min(p1, p2))) > r) {\n      return false;\n    }\n  }\n\n  if (max(v0.x, max(v1.x, v2.x)) < -0.5 || min(v0.x, min(v1.x, v2.x)) > 0.5) {\n    return false;\n  }\n  if (max(v0.y, max(v1.y, v2.y)) < -0.5 || min(v0.y, min(v1.y, v2.y)) > 0.5) {\n    return false;\n  }\n  if (max(v0.z, max(v1.z, v2.z)) < -0.5 || min(v0.z, min(v1.z, v2.z)) > 0.5) {\n    return false;\n  }\n\n  var planeNorm : vec3<f32> = normalize(cross(f1, f0));\n  var planeConst : f32 = dot(planeNorm, triangle[0]);\n  var r : f32 = 0.5 * abs(planeNorm.x) + 0.5 * abs(planeNorm.y) + 0.5 * abs(planeNorm.z);\n  var s : f32 = abs(dot(planeNorm, voxel) - planeConst);\n  return s <= r;\n}\n\nfn getVertex(index : u32) -> vec3<f32> {\n  var vertex : vec4<f32> = vec4<f32>(vertices[index][0], vertices[index][1], vertices[index][2], 1);\n  return (transform * vertex).xyz - vec3<f32>(chunk);\n}\n\nconst triangles : u32 = ${r};\n\n${t}\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var id : u32 = GlobalInvocationID.x;\n  if (id >= triangles) {\n    return;\n  }\n\n  var triangle = array<vec3<f32>, 3>(\n    getVertex(indices[id][0]),\n    getVertex(indices[id][1]),\n    getVertex(indices[id][2]),\n  );\n\n  var tmin : vec3<i32> = vec3<i32>(chunkSize);\n  var tmax : vec3<i32> = vec3<i32>(0);\n  for (var i : i32 = 0; i < 3; i++) {\n    var p = vec3<i32>(triangle[i]);\n    tmin = min(tmin, p);\n    tmax = max(tmax, p);\n  }\n  tmin = clamp(tmin, vec3<i32>(0), vec3<i32>(chunkSize - 1));\n  tmax = clamp(tmax, vec3<i32>(0), vec3<i32>(chunkSize - 1));\n\n  for (var z : i32 = tmin.z; z <= tmax.z; z++) {\n    for (var y : i32 = tmin.y; y <= tmax.y; y++) {\n      for (var x : i32 = tmin.x; x <= tmax.x; x++) {\n        if (intersects(triangle, vec3<f32>(f32(x) + 0.5, f32(y) + 0.5, f32(z) + 0.5))) {\n          var pos : vec3<i32> = vec3<i32>(x, y, z);\n          voxels[getVoxel(pos)] = getValueAt(vec3<f32>(chunk + pos));\n        }\n      }\n    }\n  }\n}\n`;class Ke{constructor({device:e,position:t=new Float32Array([0,0,0]),rotation:r=new Float32Array([0,0,0,1]),scale:s=new Float32Array([1,1,1])}){this.device=e,this.data=n(),this.buffer=e.createBuffer({mappedAtCreation:!0,size:this.data.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),o(this.data,r,t,s),new Float32Array(this.buffer.getMappedRange()).set(this.data),this.buffer.unmap()}destroy(){const{buffer:e}=this;e.destroy()}set(e,t,r){const{device:n,buffer:s,data:i}=this;o(i,t,e,r),n.queue.writeBuffer(s,0,i)}}class Qe{constructor({geometry:e,volume:t}){const r=e.indices.length/3;this.pipeline=t.device.createComputePipeline({layout:"auto",compute:{module:t.device.createShaderModule({code:Ze({chunkSize:t.chunkSize,source:e.source||"\nfn getValueAt(pos : vec3<f32>) -> f32 {\n  return 1;\n}\n",triangles:r})}),entryPoint:"main"}}),this.transform=new Ke({device:t.device,position:e.position,rotation:e.rotation,scale:e.scale}),this.indices=t.device.createBuffer({mappedAtCreation:!0,size:e.indices.byteLength,usage:GPUBufferUsage.STORAGE}),new Uint32Array(this.indices.getMappedRange()).set(e.indices),this.indices.unmap(),this.vertices=t.device.createBuffer({mappedAtCreation:!0,size:e.vertices.byteLength,usage:GPUBufferUsage.STORAGE}),new Float32Array(this.vertices.getMappedRange()).set(e.vertices),this.vertices.unmap(),this.bindings=t.chunks.map((({position:e,voxels:r})=>({bindings:t.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[e,this.transform.buffer,this.indices,this.vertices,r].map(((e,t)=>({binding:t,resource:{buffer:e}})))}),clearChunk:e=>e.clearBuffer(r)}))),this.workgroups=Math.ceil(r/64)}compute(e){const{bindings:t,pipeline:r,workgroups:n}=this;t.forEach((({bindings:t,clearChunk:s})=>{s(e);const i=e.beginComputePass();i.setPipeline(r),i.setBindGroup(0,t),i.dispatchWorkgroups(n),i.end()}))}destroy(){const{transform:e,indices:t,vertices:r}=this;e.destroy(),t.destroy(),r.destroy()}}const et=({chunkSize:e,width:t,height:r,depth:n,source:s})=>`\n@group(0) @binding(0) var<uniform> time : f32;\n@group(0) @binding(1) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(2) var<storage, read_write> voxels : array<f32>;\n\n${p}\n${y}\nfn sdBox(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var q : vec3<f32> = abs(p) - r;\n  return length(max(q, vec3<f32>(0))) + min(max(q.x, max(q.y, q.z)), 0);\n}\n\nfn sdCapsule(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var q : vec3<f32> = vec3<f32>(p.x, clamp(p.y, -r.y + r.x, r.y - r.x), p.y);\n  return length(q) - q.x;\n}\n\nfn sdEllipsoid(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var k0 : f32 = length(p / r);\n  var k1 : f32 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\n\nfn sdSphere(p : vec3<f32>, r : f32) -> f32 {\n  return length(p) - r;\n}\n\nfn sdTorus(p : vec3<f32>, r : vec2<f32>) -> f32 {\n  var q : vec2<f32> = vec2<f32>(length(p.xz) - r.x, p.y);\n  return length(q) - r.y;\n}\n\nfn opUnion(d1 : f32, d2 : f32) -> f32 {\n  return min(d1, d2);\n}\n\nfn opSubstraction(d1 : f32, d2 : f32) -> f32 {\n  return max(d1, -d2);\n}\n\nfn opSmoothUnion(d1 : f32, d2 : f32, k : f32) -> f32 {\n  var h : f32 = clamp(0.5 + 0.5 * (d2 - d1) / k, 0, 1);\n  return mix(d2, d1, h) + k * h * (1 - h);\n}\n\nfn opSmoothSubstraction(d1 : f32, d2 : f32, k : f32) -> f32 {\n  var h : f32 = clamp(0.5 - 0.5 * (d2 + d1) / k, 0, 1);\n  return mix(d1, -d2, h) + k * h * (1 - h);\n}\n\n${He({chunkSize:e})}\n\nstruct Volume {\n  center : vec3<f32>,\n  size : vec3<f32>,\n}\n\nconst volume : Volume = Volume(\n  vec3<f32>(${.5*t}, ${.5*r}, ${.5*n}),\n  vec3<f32>(${t}, ${r}, ${n})\n);\n\n${s}\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize || pos.y >= chunkSize || pos.z >= chunkSize\n  ) {\n    return;\n  }\n  voxels[getVoxel(pos)] = getValueAt(vec3<f32>(chunk + pos));\n}\n`;class tt{constructor({source:e,volume:t}){this.pipeline=t.device.createComputePipeline({layout:"auto",compute:{module:t.device.createShaderModule({code:et({chunkSize:t.chunkSize,width:t.width,height:t.height,depth:t.depth,source:e})}),entryPoint:"main"}}),this.bindings=t.chunks.map((({position:e,voxels:r})=>t.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[t.time.buffer,e,r].map(((e,t)=>({binding:t,resource:{buffer:e}})))}))),this.workgroups=Math.ceil(t.chunkSize/4)}compute(e){const{bindings:t,pipeline:r,workgroups:n}=this;t.forEach((t=>{const s=e.beginComputePass();s.setPipeline(r),s.setBindGroup(0,t),s.dispatchWorkgroups(n,n,n),s.end()}))}}class rt{constructor({device:e,chunk:t,chunkSize:r}){this.chunk=t,this.faces=e.createBuffer({mappedAtCreation:!0,size:4*Uint32Array.BYTES_PER_ELEMENT+6*Math.ceil(r*r*r*.5)*4*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),new Uint32Array(this.faces.getMappedRange())[0]=6,this.faces.unmap(),this.position=e.createBuffer({mappedAtCreation:!0,size:3*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM}),new Int32Array(this.position.getMappedRange()).set([t.x*r,t.y*r,t.z*r]),this.position.unmap(),this.voxels=rt.createVoxelsBuffer({device:e,chunkSize:r})}destroy(){const{faces:e,position:t,voxels:r}=this;e.destroy(),t.destroy(),r.destroy()}resetInstanceCount(e){const{faces:t}=this;e.clearBuffer(t,4,4)}static createVoxelsBuffer({device:e,chunkSize:t}){return e.createBuffer({size:t*t*t*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE})}}class nt{constructor({device:e}){this.device=e,this.data=new Float32Array(1),this.buffer=e.createBuffer({size:this.data.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM})}destroy(){const{buffer:e}=this;e.destroy()}set(e){const{device:t,buffer:r,data:n}=this;n[0]=e,t.queue.writeBuffer(r,0,n)}}class st{constructor({chunkSize:e=100,device:t,width:r,height:n,depth:s}){this.chunkSize=e,this.device=t,this.width=r,this.height=n,this.depth=s;const i={x:Math.ceil(r/e),y:Math.ceil(n/e),z:Math.ceil(s/e)};this.chunks=[];for(let r=0;r<i.z;r++)for(let n=0;n<i.y;n++)for(let s=0;s<i.x;s++)this.chunks.push(new rt({device:t,chunk:{x:s,y:n,z:r},chunkSize:e}));this.edge=rt.createVoxelsBuffer({device:t,chunkSize:e}),this.mesher=new Xe({chunks:i,volume:this}),this.time=new nt({device:t})}compute(e,t){const{mesher:r,time:n,voxelizer:s}=this;n.set(t),s.compute(e),r.compute(e)}destroy(){const{chunks:e,edge:t,time:r,voxelizer:n}=this;e.forEach((e=>e.destroy())),t.destroy(),r.destroy(),n&&n.destroy&&n.destroy()}setScene(e){const{voxelizer:t}=this;t&&t.destroy&&t.destroy(),e.geometry?this.voxelizer=new Qe({geometry:e.geometry,volume:this}):e.source&&(this.voxelizer=new tt({source:e.source,volume:this}))}}(async()=>{if(!navigator.gpu||!navigator.gpu.getPreferredCanvasFormat)throw new Error("WebGPU");const e=await navigator.gpu.requestAdapter(),t=await e.requestDevice(),r=new R({adapter:e,device:t});document.getElementById("renderer").appendChild(r.canvas),r.setSize(window.innerWidth,window.innerHeight),window.addEventListener("resize",(()=>r.setSize(window.innerWidth,window.innerHeight)),!1);const n=new st({device:t,width:300,height:300,depth:300});f(r.camera.target,.5*n.width,.5*n.height,.5*n.depth);let s,i,o,a=performance.now()/1e3;const c=We(n),u=document.getElementById("source"),l=e=>{if(c[e].loading)return void l((e+1)%c.length);s=c[e],i=e,o=-1;let t=s.source||"";t.includes("fn distanceToScene(pos : vec3<f32>) -> f32")&&(t=t.slice(0,t.indexOf("fn getValueAt(pos : vec3<f32>) -> f32"))),u.innerText=t,r.atlas.compute(s.atlas),n.setScene(s),s.onLoad&&s.onLoad(r,n)};l(0),setInterval((()=>l((i+1)%c.length)),1e4);const h=()=>{requestAnimationFrame(h);const e=performance.now()/1e3,i=e-a;a=e,s.onAnimation&&s.onAnimation(i,e,r,n);const c=t.createCommandEncoder();(void 0===s.maxFPS||s.maxFPS>0&&o<=e-1/s.maxFPS||-1===o)&&(o=e,n.compute(c,e)),r.render(c,n),t.queue.submit([c.finish()])};requestAnimationFrame(h)})().catch((e=>{console.error(e),document.getElementById("canary").classList.add("enabled")})).finally((()=>document.getElementById("loading").classList.remove("enabled")))}();
